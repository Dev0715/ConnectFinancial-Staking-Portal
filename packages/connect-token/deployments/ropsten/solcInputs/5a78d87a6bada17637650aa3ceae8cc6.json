{
  "language": "Solidity",
  "sources": {
    "contracts/governance/GovernorAlpha.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport { ITimelock } from \"../interfaces/ITimelock.sol\";\r\nimport { ICND } from \"../interfaces/ICND.sol\";\r\n\r\ncontract GovernorAlpha {\r\n    /// @notice The name of this contract\r\n    string public constant name = \"Connect Governor Alpha\";\r\n\r\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\r\n    function quorumVotes() public pure returns (uint) { return 400000e18; } // 400,000 = 4% of Comp\r\n\r\n    /// @notice The number of votes required in order for a voter to become a proposer\r\n    function proposalThreshold() public pure returns (uint) { return 100000e18; } // 100,000 = 1% of Comp\r\n\r\n    /// @notice The maximum number of actions that can be included in a proposal\r\n    function proposalMaxOperations() public pure returns (uint) { return 10; } // 10 actions\r\n\r\n    /// @notice The delay before voting on a proposal may take place, once proposed\r\n    function votingDelay() public pure returns (uint) { return 1; } // 1 block\r\n\r\n    /// @notice The duration of voting on a proposal, in blocks\r\n    function votingPeriod() public pure returns (uint) { return 17280; } // ~3 days in blocks (assuming 15s blocks)\r\n\r\n    /// @notice The address of the Connect Protocol Timelock\r\n    ITimelock public timelock;\r\n\r\n    /// @notice The address of the Connect governance token\r\n    ICND public cnd;\r\n\r\n    /// @notice The address of the Governor Guardian\r\n    address public guardian;\r\n\r\n    /// @notice The total number of proposals\r\n    uint public proposalCount;\r\n\r\n    struct Proposal {\r\n        /// @notice Unique id for looking up a proposal\r\n        uint id;\r\n\r\n        /// @notice Creator of the proposal\r\n        address proposer;\r\n\r\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\r\n        uint eta;\r\n\r\n        /// @notice the ordered list of target addresses for calls to be made\r\n        address[] targets;\r\n\r\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\r\n        uint[] values;\r\n\r\n        /// @notice The ordered list of function signatures to be called\r\n        string[] signatures;\r\n\r\n        /// @notice The ordered list of calldata to be passed to each call\r\n        bytes[] calldatas;\r\n\r\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\r\n        uint startBlock;\r\n\r\n        /// @notice The block at which voting ends: votes must be cast prior to this block\r\n        uint endBlock;\r\n\r\n        /// @notice Current number of votes in favor of this proposal\r\n        uint forVotes;\r\n\r\n        /// @notice Current number of votes in opposition to this proposal\r\n        uint againstVotes;\r\n\r\n        /// @notice Flag marking whether the proposal has been canceled\r\n        bool canceled;\r\n\r\n        /// @notice Flag marking whether the proposal has been executed\r\n        bool executed;\r\n\r\n        /// @notice Receipts of ballots for the entire set of voters\r\n        mapping (address => Receipt) receipts;\r\n    }\r\n\r\n    /// @notice Ballot receipt record for a voter\r\n    struct Receipt {\r\n        /// @notice Whether or not a vote has been cast\r\n        bool hasVoted;\r\n\r\n        /// @notice Whether or not the voter supports the proposal\r\n        bool support;\r\n\r\n        /// @notice The number of votes the voter had, which were cast\r\n        uint96 votes;\r\n    }\r\n\r\n    /// @notice Possible states that a proposal may be in\r\n    enum ProposalState {\r\n        Pending,\r\n        Active,\r\n        Canceled,\r\n        Defeated,\r\n        Succeeded,\r\n        Queued,\r\n        Expired,\r\n        Executed\r\n    }\r\n\r\n    /// @notice The official record of all proposals ever proposed\r\n    mapping (uint => Proposal) public proposals;\r\n\r\n    /// @notice The latest proposal for each proposer\r\n    mapping (address => uint) public latestProposalIds;\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\r\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\r\n\r\n    /// @notice An event emitted when a new proposal is created\r\n    event ProposalCreated(uint id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description);\r\n\r\n    /// @notice An event emitted when a vote has been cast on a proposal\r\n    event VoteCast(address voter, uint proposalId, bool support, uint votes);\r\n\r\n    /// @notice An event emitted when a proposal has been canceled\r\n    event ProposalCanceled(uint id);\r\n\r\n    /// @notice An event emitted when a proposal has been queued in the Timelock\r\n    event ProposalQueued(uint id, uint eta);\r\n\r\n    /// @notice An event emitted when a proposal has been executed in the Timelock\r\n    event ProposalExecuted(uint id);\r\n\r\n    constructor(address timelock_, address cnd_, address guardian_) public {\r\n        timelock = ITimelock(timelock_);\r\n        cnd = ICND(cnd_);\r\n        guardian = guardian_;\r\n    }\r\n\r\n    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\r\n        require(cnd.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\r\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\r\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\r\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\r\n\r\n        uint latestProposalId = latestProposalIds[msg.sender];\r\n        if (latestProposalId != 0) {\r\n          ProposalState proposersLatestProposalState = state(latestProposalId);\r\n          require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\r\n          require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\r\n        }\r\n\r\n        uint startBlock = add256(block.number, votingDelay());\r\n        uint endBlock = add256(startBlock, votingPeriod());\r\n\r\n        proposalCount++;\r\n        Proposal memory newProposal = Proposal({\r\n            id: proposalCount,\r\n            proposer: msg.sender,\r\n            eta: 0,\r\n            targets: targets,\r\n            values: values,\r\n            signatures: signatures,\r\n            calldatas: calldatas,\r\n            startBlock: startBlock,\r\n            endBlock: endBlock,\r\n            forVotes: 0,\r\n            againstVotes: 0,\r\n            canceled: false,\r\n            executed: false\r\n        });\r\n\r\n        proposals[newProposal.id] = newProposal;\r\n        latestProposalIds[newProposal.proposer] = newProposal.id;\r\n\r\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\r\n        return newProposal.id;\r\n    }\r\n\r\n    function queue(uint proposalId) public {\r\n        require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\r\n        Proposal storage proposal = proposals[proposalId];\r\n        uint eta = add256(block.timestamp, timelock.delay());\r\n        for (uint i = 0; i < proposal.targets.length; i++) {\r\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\r\n        }\r\n        proposal.eta = eta;\r\n        emit ProposalQueued(proposalId, eta);\r\n    }\r\n\r\n    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\r\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\");\r\n        timelock.queueTransaction(target, value, signature, data, eta);\r\n    }\r\n\r\n    function execute(uint proposalId) public payable {\r\n        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\r\n        Proposal storage proposal = proposals[proposalId];\r\n        proposal.executed = true;\r\n        for (uint i = 0; i < proposal.targets.length; i++) {\r\n            timelock.executeTransaction{ value: proposal.values[i] }(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\r\n        }\r\n        emit ProposalExecuted(proposalId);\r\n    }\r\n\r\n    function cancel(uint proposalId) public {\r\n        ProposalState state = state(proposalId);\r\n        require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\r\n\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(msg.sender == guardian || cnd.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(), \"GovernorAlpha::cancel: proposer above threshold\");\r\n\r\n        proposal.canceled = true;\r\n        for (uint i = 0; i < proposal.targets.length; i++) {\r\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\r\n        }\r\n\r\n        emit ProposalCanceled(proposalId);\r\n    }\r\n\r\n    function getActions(uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\r\n        Proposal storage p = proposals[proposalId];\r\n        return (p.targets, p.values, p.signatures, p.calldatas);\r\n    }\r\n\r\n    function getReceipt(uint proposalId, address voter) public view returns (Receipt memory) {\r\n        return proposals[proposalId].receipts[voter];\r\n    }\r\n\r\n    function state(uint proposalId) public view returns (ProposalState) {\r\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\r\n        Proposal storage proposal = proposals[proposalId];\r\n        if (proposal.canceled) {\r\n            return ProposalState.Canceled;\r\n        } else if (block.number <= proposal.startBlock) {\r\n            return ProposalState.Pending;\r\n        } else if (block.number <= proposal.endBlock) {\r\n            return ProposalState.Active;\r\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\r\n            return ProposalState.Defeated;\r\n        } else if (proposal.eta == 0) {\r\n            return ProposalState.Succeeded;\r\n        } else if (proposal.executed) {\r\n            return ProposalState.Executed;\r\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\r\n            return ProposalState.Expired;\r\n        } else {\r\n            return ProposalState.Queued;\r\n        }\r\n    }\r\n\r\n    function castVote(uint proposalId, bool support) public {\r\n        return _castVote(msg.sender, proposalId, support);\r\n    }\r\n\r\n    function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public {\r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\r\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\r\n        return _castVote(signatory, proposalId, support);\r\n    }\r\n\r\n    function _castVote(address voter, uint proposalId, bool support) internal {\r\n        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\r\n        Proposal storage proposal = proposals[proposalId];\r\n        Receipt storage receipt = proposal.receipts[voter];\r\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\r\n        uint96 votes = cnd.getPriorVotes(voter, proposal.startBlock);\r\n\r\n        if (support) {\r\n            proposal.forVotes = add256(proposal.forVotes, votes);\r\n        } else {\r\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\r\n        }\r\n\r\n        receipt.hasVoted = true;\r\n        receipt.support = support;\r\n        receipt.votes = votes;\r\n\r\n        emit VoteCast(voter, proposalId, support, votes);\r\n    }\r\n\r\n    function __acceptAdmin() public {\r\n        require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\r\n        timelock.acceptAdmin();\r\n    }\r\n\r\n    function __abdicate() public {\r\n        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\r\n        guardian = address(0);\r\n    }\r\n\r\n    function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\r\n        require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\r\n        timelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\r\n    }\r\n\r\n    function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\r\n        require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\r\n        timelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\r\n    }\r\n\r\n    function add256(uint256 a, uint256 b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub256(uint256 a, uint256 b) internal pure returns (uint) {\r\n        require(b <= a, \"subtraction underflow\");\r\n        return a - b;\r\n    }\r\n\r\n    function getChainId() internal pure returns (uint) {\r\n        uint chainId;\r\n        assembly { chainId := chainid() }\r\n        return chainId;\r\n    }\r\n}\r\n\r\n"
    },
    "contracts/interfaces/ITimelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\ninterface ITimelock {\r\n    function delay() external view returns (uint);\r\n    function GRACE_PERIOD() external view returns (uint);\r\n    function acceptAdmin() external;\r\n    function queuedTransactions(bytes32 hash) external view returns (bool);\r\n    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\r\n    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\r\n    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\r\n}\r\n\r\n"
    },
    "contracts/interfaces/ICND.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\ninterface ICND {\r\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint96);\r\n}\r\n"
    },
    "contracts/governance/Timelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\ncontract Timelock {\r\n    using SafeMath for uint;\r\n\r\n    event NewAdmin(address indexed newAdmin);\r\n    event NewPendingAdmin(address indexed newPendingAdmin);\r\n    event NewDelay(uint indexed newDelay);\r\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\r\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\r\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\r\n\r\n    uint public constant GRACE_PERIOD = 14 days;\r\n    uint public constant MINIMUM_DELAY = 2 days;\r\n    uint public constant MAXIMUM_DELAY = 30 days;\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    uint public delay;\r\n\r\n    mapping (bytes32 => bool) public queuedTransactions;\r\n\r\n\r\n    constructor(address admin_, uint delay_) public {\r\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\r\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n\r\n        admin = admin_;\r\n        delay = delay_;\r\n    }\r\n\r\n    fallback() external payable { }\r\n    receive() external payable { }\r\n\r\n    function setDelay(uint delay_) public {\r\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\r\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\r\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n        delay = delay_;\r\n\r\n        emit NewDelay(delay);\r\n    }\r\n\r\n    function acceptAdmin() public {\r\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\r\n        admin = msg.sender;\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(admin);\r\n    }\r\n\r\n    function setPendingAdmin(address pendingAdmin_) public {\r\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\r\n        pendingAdmin = pendingAdmin_;\r\n\r\n        emit NewPendingAdmin(pendingAdmin);\r\n    }\r\n\r\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\r\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\r\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        queuedTransactions[txHash] = true;\r\n\r\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\r\n        return txHash;\r\n    }\r\n\r\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\r\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        queuedTransactions[txHash] = false;\r\n\r\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\r\n    }\r\n\r\n    function executeTransaction(address payable target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\r\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\r\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\r\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\r\n\r\n        queuedTransactions[txHash] = false;\r\n\r\n        bytes memory callData;\r\n\r\n        if (bytes(signature).length == 0) {\r\n            callData = data;\r\n        } else {\r\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\r\n        }\r\n\r\n        // solium-disable-next-line security/no-call-value\r\n        (bool success, bytes memory returnData) = target.call{ value: value }(callData);\r\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\r\n\r\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\r\n\r\n        return returnData;\r\n    }\r\n\r\n    function getBlockTimestamp() internal view returns (uint) {\r\n        // solium-disable-next-line security/no-block-members\r\n        return block.timestamp;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "arb-bridge-peripherals/contracts/tokenbridge/arbitrum/gateway/L2CustomGateway.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./L2ArbitrumGateway.sol\";\nimport \"../../libraries/gateway/ICustomGateway.sol\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract L2CustomGateway is L2ArbitrumGateway, ICustomGateway {\n    // stores addresses of L2 tokens to be used\n    mapping(address => address) public override l1ToL2Token;\n\n    function initialize(address _l1Counterpart, address _router) public {\n        L2ArbitrumGateway._initialize(_l1Counterpart, _router);\n    }\n\n    /**\n     * @notice internal utility function used to handle when no contract is deployed at expected address\n     */\n    function handleNoContract(\n        address _l1Token,\n        address, /* expectedL2Address */\n        address _from,\n        address, /* _to */\n        uint256 _amount,\n        bytes memory /* gatewayData */\n    ) internal override returns (bool shouldHalt) {\n        // it is assumed that the custom token is deployed in the L2 before deposits are made\n        // trigger withdrawal\n        // we don't need the return value from triggerWithdrawal since this is forcing a withdrawal back to the L1\n        // instead of composing with a L2 dapp\n        triggerWithdrawal(_l1Token, address(this), _from, _amount, \"\");\n        return true;\n    }\n\n    function outboundEscrowTransfer(\n        address _l2Token,\n        address _from,\n        uint256 _amount\n    ) internal override returns (uint256 amountBurnt) {\n        uint256 prevBalance = IERC20(_l2Token).balanceOf(_from);\n\n        // in the custom gateway, we do the same behaviour as the superclass, but actually check\n        // for the balances of tokens to ensure that inflationary / deflationary changes in the amount\n        // are taken into account\n        // we ignore the return value since we actually query the token before and after to calculate\n        // the amount of tokens that were burnt\n        super.outboundEscrowTransfer(_l2Token, _from, _amount);\n\n        uint256 postBalance = IERC20(_l2Token).balanceOf(_from);\n        return SafeMath.sub(prevBalance, postBalance);\n    }\n\n    /**\n     * @notice Calculate the address used when bridging an ERC20 token\n     * @dev the L1 and L2 address oracles may not always be in sync.\n     * For example, a custom token may have been registered but not deploy or the contract self destructed.\n     * @param l1ERC20 address of L1 token\n     * @return L2 address of a bridged ERC20 token\n     */\n    function calculateL2TokenAddress(address l1ERC20) public view override returns (address) {\n        return l1ToL2Token[l1ERC20];\n    }\n\n    function registerTokenFromL1(address[] calldata l1Address, address[] calldata l2Address)\n        external\n        onlyCounterpartGateway\n    {\n        // we assume both arrays are the same length, safe since its encoded by the L1\n        for (uint256 i = 0; i < l1Address.length; i++) {\n            // here we don't check if l2Address is a contract and instead deal with that behaviour\n            // in `handleNoContract` this way we keep the l1 and l2 address oracles in sync\n            l1ToL2Token[l1Address[i]] = l2Address[i];\n            emit TokenSet(l1Address[i], l2Address[i]);\n        }\n    }\n}\n"
    },
    "arb-bridge-peripherals/contracts/tokenbridge/arbitrum/gateway/L2ArbitrumGateway.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"arb-bridge-eth/contracts/libraries/BytesLib.sol\";\nimport \"arb-bridge-eth/contracts/libraries/ProxyUtil.sol\";\nimport \"arb-bridge-eth/contracts/libraries/AddressAliasHelper.sol\";\n\nimport \"../IArbToken.sol\";\n\nimport \"../L2ArbitrumMessenger.sol\";\nimport \"../../libraries/gateway/GatewayMessageHandler.sol\";\nimport \"../../libraries/gateway/TokenGateway.sol\";\n\n/**\n * @title Common interface for gatways on Arbitrum messaging to L1.\n */\nabstract contract L2ArbitrumGateway is L2ArbitrumMessenger, TokenGateway {\n    using Address for address;\n\n    uint256 public exitNum;\n\n    event DepositFinalized(\n        address indexed l1Token,\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount\n    );\n\n    event WithdrawalInitiated(\n        address l1Token,\n        address indexed _from,\n        address indexed _to,\n        uint256 indexed _l2ToL1Id,\n        uint256 _exitNum,\n        uint256 _amount\n    );\n\n    modifier onlyCounterpartGateway() override {\n        require(\n            msg.sender == counterpartGateway ||\n                AddressAliasHelper.undoL1ToL2Alias(msg.sender) == counterpartGateway,\n            \"ONLY_COUNTERPART_GATEWAY\"\n        );\n        _;\n    }\n\n    function postUpgradeInit() external {\n        // it is assumed the L2 Arbitrum Gateway contract is behind a Proxy controlled by a proxy admin\n        // this function can only be called by the proxy admin contract\n        address proxyAdmin = ProxyUtil.getProxyAdmin();\n        require(msg.sender == proxyAdmin, \"NOT_FROM_ADMIN\");\n        // this has no other logic since the current upgrade doesn't require this logic\n    }\n\n    function _initialize(address _l1Counterpart, address _router) internal virtual override {\n        TokenGateway._initialize(_l1Counterpart, _router);\n        // L1 gateway must have a router\n        require(_router != address(0), \"BAD_ROUTER\");\n    }\n\n    function createOutboundTx(\n        address _from,\n        uint256, /* _tokenAmount */\n        bytes memory _outboundCalldata\n    ) internal virtual returns (uint256) {\n        // We make this function virtual since outboundTransfer logic is the same for many gateways\n        // but sometimes (ie weth) you construct the outgoing message differently.\n\n        // exitNum incremented after being included in _outboundCalldata\n        exitNum++;\n        return\n            sendTxToL1(\n                // default to sending no callvalue to the L1\n                0,\n                _from,\n                counterpartGateway,\n                _outboundCalldata\n            );\n    }\n\n    function getOutboundCalldata(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) public view override returns (bytes memory outboundCalldata) {\n        outboundCalldata = abi.encodeWithSelector(\n            TokenGateway.finalizeInboundTransfer.selector,\n            _token,\n            _from,\n            _to,\n            _amount,\n            GatewayMessageHandler.encodeFromL2GatewayMsg(exitNum, _data)\n        );\n\n        return outboundCalldata;\n    }\n\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) public payable virtual returns (bytes memory) {\n        return outboundTransfer(_l1Token, _to, _amount, 0, 0, _data);\n    }\n\n    /**\n     * @notice Initiates a token withdrawal from Arbitrum to Ethereum\n     * @param _l1Token l1 address of token\n     * @param _to destination address\n     * @param _amount amount of tokens withdrawn\n     * @return res encoded unique identifier for withdrawal\n     */\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        uint256, /* _maxGas */\n        uint256, /* _gasPriceBid */\n        bytes calldata _data\n    ) public payable virtual override returns (bytes memory res) {\n        // This function is set as public and virtual so that subclasses can override\n        // it and add custom validation for callers (ie only whitelisted users)\n\n        // the function is marked as payable to conform to the inheritance setup\n        // this particular code path shouldn't have a msg.value > 0\n        // TODO: remove this invariant for execution markets\n        require(msg.value == 0, \"NO_VALUE\");\n\n        address _from;\n        bytes memory _extraData;\n        {\n            if (isRouter(msg.sender)) {\n                (_from, _extraData) = GatewayMessageHandler.parseFromRouterToGateway(_data);\n            } else {\n                _from = msg.sender;\n                _extraData = _data;\n            }\n        }\n        // the inboundEscrowAndCall functionality has been disabled, so no data is allowed\n        require(_extraData.length == 0, \"EXTRA_DATA_DISABLED\");\n\n        uint256 id;\n        {\n            address l2Token = calculateL2TokenAddress(_l1Token);\n            require(l2Token.isContract(), \"TOKEN_NOT_DEPLOYED\");\n            require(IArbToken(l2Token).l1Address() == _l1Token, \"NOT_EXPECTED_L1_TOKEN\");\n\n            _amount = outboundEscrowTransfer(l2Token, _from, _amount);\n            id = triggerWithdrawal(_l1Token, _from, _to, _amount, _extraData);\n        }\n        return abi.encode(id);\n    }\n\n    function triggerWithdrawal(\n        address _l1Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) internal returns (uint256) {\n        // exit number used for tradeable exits\n        uint256 currExitNum = exitNum;\n        // unique id used to identify the L2 to L1 tx\n        uint256 id = createOutboundTx(\n            _from,\n            _amount,\n            getOutboundCalldata(_l1Token, _from, _to, _amount, _data)\n        );\n        emit WithdrawalInitiated(_l1Token, _from, _to, id, currExitNum, _amount);\n        return id;\n    }\n\n    function outboundEscrowTransfer(\n        address _l2Token,\n        address _from,\n        uint256 _amount\n    ) internal virtual returns (uint256 amountBurnt) {\n        // this method is virtual since different subclasses can handle escrow differently\n        // user funds are escrowed on the gateway using this function\n        // burns L2 tokens in order to release escrowed L1 tokens\n        IArbToken(_l2Token).bridgeBurn(_from, _amount);\n        // by default we assume that the amount we send to bridgeBurn is the amount burnt\n        // this might not be the case for every token\n        return _amount;\n    }\n\n    function inboundEscrowTransfer(\n        address _l2Address,\n        address _dest,\n        uint256 _amount\n    ) internal virtual {\n        // this method is virtual since different subclasses can handle escrow differently\n        IArbToken(_l2Address).bridgeMint(_dest, _amount);\n    }\n\n    /**\n     * @notice Mint on L2 upon L1 deposit.\n     * If token not yet deployed and symbol/name/decimal data is included, deploys StandardArbERC20\n     * @dev Callable only by the L1ERC20Gateway.outboundTransfer method. For initial deployments of a token the L1 L1ERC20Gateway\n     * is expected to include the deployData. If not a L1 withdrawal is automatically triggered for the user\n     * @param _token L1 address of ERC20\n     * @param _from account that initiated the deposit in the L1\n     * @param _to account to be credited with the tokens in the L2 (can be the user's L2 account or a contract)\n     * @param _amount token amount to be minted to the user\n     * @param _data encoded symbol/name/decimal data for deploy, in addition to any additional callhook data\n     */\n    function finalizeInboundTransfer(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override onlyCounterpartGateway {\n        (bytes memory gatewayData, bytes memory callHookData) = GatewayMessageHandler\n            .parseFromL1GatewayMsg(_data);\n\n        if (callHookData.length != 0) {\n            // callHookData should always be 0 since inboundEscrowAndCall is disabled\n            callHookData = bytes(\"\");\n        }\n\n        address expectedAddress = calculateL2TokenAddress(_token);\n\n        if (!expectedAddress.isContract()) {\n            bool shouldHalt = handleNoContract(\n                _token,\n                expectedAddress,\n                _from,\n                _to,\n                _amount,\n                gatewayData\n            );\n            if (shouldHalt) return;\n        }\n        // ignores gatewayData if token already deployed\n\n        {\n            // validate if L1 address supplied matches that of the expected L2 address\n            (bool success, bytes memory _l1AddressData) = expectedAddress.staticcall(\n                abi.encodeWithSelector(IArbToken.l1Address.selector)\n            );\n\n            bool shouldWithdraw;\n            if (!success || _l1AddressData.length < 32) {\n                shouldWithdraw = true;\n            } else {\n                // we do this in the else branch since we want to avoid reverts\n                // and `toAddress` reverts if _l1AddressData has a short length\n                // `_l1AddressData` should be 12 bytes of padding then 20 bytes for the address\n                address expectedL1Address = BytesLib.toAddress(_l1AddressData, 12);\n                if (expectedL1Address != _token) {\n                    shouldWithdraw = true;\n                }\n            }\n\n            if (shouldWithdraw) {\n                // we don't need the return value from triggerWithdrawal since this is forcing\n                // a withdrawal back to the L1 instead of composing with a L2 dapp\n                triggerWithdrawal(_token, address(this), _from, _amount, \"\");\n                return;\n            }\n        }\n\n        inboundEscrowTransfer(expectedAddress, _to, _amount);\n        emit DepositFinalized(_token, _from, _to, _amount);\n\n        return;\n    }\n\n    // returns if function should halt after\n    function handleNoContract(\n        address _l1Token,\n        address expectedL2Address,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory gatewayData\n    ) internal virtual returns (bool shouldHalt);\n}\n"
    },
    "arb-bridge-peripherals/contracts/tokenbridge/libraries/gateway/ICustomGateway.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\n// import \"./ITokenGateway.sol\";\n\ninterface ICustomGateway {\n    function l1ToL2Token(address _l1Token) external view returns (address _l2Token);\n\n    event TokenSet(address indexed l1Address, address indexed l2Address);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "arb-bridge-eth/contracts/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonalo S <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\n\npragma solidity ^0.6.11;\n\n/* solhint-disable no-inline-assembly */\nlibrary BytesLib {\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= (_start + 20), \"Read out of bounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= (_start + 1), \"Read out of bounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= (_start + 32), \"Read out of bounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= (_start + 32), \"Read out of bounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n}\n/* solhint-enable no-inline-assembly */\n"
    },
    "arb-bridge-eth/contracts/libraries/ProxyUtil.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nlibrary ProxyUtil {\n    function getProxyAdmin() internal view returns (address admin) {\n        // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/proxy/TransparentUpgradeableProxy.sol#L48\n        // Storage slot with the admin of the proxy contract.\n        // This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n        bytes32 slot = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n        assembly {\n            admin := sload(slot)\n        }\n    }\n}\n"
    },
    "arb-bridge-eth/contracts/libraries/AddressAliasHelper.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nlibrary AddressAliasHelper {\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        l2Address = address(uint160(l1Address) + offset);\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        l1Address = address(uint160(l2Address) - offset);\n    }\n}\n"
    },
    "arb-bridge-peripherals/contracts/tokenbridge/arbitrum/IArbToken.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @title Minimum expected interface for L2 token that interacts with the L2 token bridge (this is the interface necessary\n * for a custom token that interacts with the bridge, see TestArbCustomToken.sol for an example implementation).\n */\npragma solidity ^0.6.11;\n\ninterface IArbToken {\n    /**\n     * @notice should increase token supply by amount, and should (probably) only be callable by the L1 bridge.\n     */\n    function bridgeMint(address account, uint256 amount) external;\n\n    /**\n     * @notice should decrease token supply by amount, and should (probably) only be callable by the L1 bridge.\n     */\n    function bridgeBurn(address account, uint256 amount) external;\n\n    /**\n     * @return address of layer 1 token\n     */\n    function l1Address() external view returns (address);\n}\n"
    },
    "arb-bridge-peripherals/contracts/tokenbridge/arbitrum/L2ArbitrumMessenger.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"arbos-precompiles/arbos/builtin/ArbSys.sol\";\n\n/// @notice L2 utility contract to assist with L1 <=> L2 interactions\n/// @dev this is an abstract contract instead of library so the functions can be easily overriden when testing\nabstract contract L2ArbitrumMessenger {\n    address internal constant ARB_SYS_ADDRESS = address(100);\n\n    event TxToL1(address indexed _from, address indexed _to, uint256 indexed _id, bytes _data);\n\n    function sendTxToL1(\n        uint256 _l1CallValue,\n        address _from,\n        address _to,\n        bytes memory _data\n    ) internal virtual returns (uint256) {\n        uint256 _id = ArbSys(ARB_SYS_ADDRESS).sendTxToL1{ value: _l1CallValue }(_to, _data);\n        emit TxToL1(_from, _to, _id, _data);\n        return _id;\n    }\n}\n"
    },
    "arb-bridge-peripherals/contracts/tokenbridge/libraries/gateway/GatewayMessageHandler.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\n/// @notice this library manages encoding and decoding of gateway communication\nlibrary GatewayMessageHandler {\n    // these are for communication from L1 to L2 gateway\n\n    function encodeToL2GatewayMsg(bytes memory gatewayData, bytes memory callHookData)\n        internal\n        pure\n        returns (bytes memory res)\n    {\n        res = abi.encode(gatewayData, callHookData);\n    }\n\n    function parseFromL1GatewayMsg(bytes calldata _data)\n        internal\n        pure\n        returns (bytes memory gatewayData, bytes memory callHookData)\n    {\n        // abi decode may revert, but the encoding is done by L1 gateway, so we trust it\n        (gatewayData, callHookData) = abi.decode(_data, (bytes, bytes));\n    }\n\n    // these are for communication from L2 to L1 gateway\n\n    function encodeFromL2GatewayMsg(uint256 exitNum, bytes memory callHookData)\n        internal\n        pure\n        returns (bytes memory res)\n    {\n        res = abi.encode(exitNum, callHookData);\n    }\n\n    function parseToL1GatewayMsg(bytes calldata _data)\n        internal\n        pure\n        returns (uint256 exitNum, bytes memory callHookData)\n    {\n        // abi decode may revert, but the encoding is done by L1 gateway, so we trust it\n        (exitNum, callHookData) = abi.decode(_data, (uint256, bytes));\n    }\n\n    // these are for communication from router to gateway\n\n    function encodeFromRouterToGateway(address _from, bytes calldata _data)\n        internal\n        pure\n        returns (bytes memory res)\n    {\n        // abi decode may revert, but the encoding is done by L1 gateway, so we trust it\n        return abi.encode(_from, _data);\n    }\n\n    function parseFromRouterToGateway(bytes calldata _data)\n        internal\n        pure\n        returns (address, bytes memory res)\n    {\n        // abi decode may revert, but the encoding is done by L1 gateway, so we trust it\n        return abi.decode(_data, (address, bytes));\n    }\n}\n"
    },
    "arb-bridge-peripherals/contracts/tokenbridge/libraries/gateway/TokenGateway.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./ITokenGateway.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nabstract contract TokenGateway is ITokenGateway {\n    using Address for address;\n\n    address public counterpartGateway;\n    address public router;\n\n    modifier onlyCounterpartGateway() virtual {\n        // this method is overriden in gateways that require special logic for validation\n        // ie L2 to L1 messages need to be validated against the outbox\n        require(msg.sender == counterpartGateway, \"ONLY_COUNTERPART_GATEWAY\");\n        _;\n    }\n\n    function _initialize(address _counterpartGateway, address _router) internal virtual {\n        // This initializes internal variables of the abstract contract it can be chained together with other functions.\n        // It is virtual so subclasses can override or wrap around this logic.\n        // An example where this is useful is different subclasses that validate the router address differently\n        require(_counterpartGateway != address(0), \"INVALID_COUNTERPART\");\n        require(counterpartGateway == address(0), \"ALREADY_INIT\");\n        counterpartGateway = _counterpartGateway;\n        router = _router;\n    }\n\n    function isRouter(address _target) internal view returns (bool isTargetRouter) {\n        return _target == router;\n    }\n\n    /**\n     * @notice Calculate the address used when bridging an ERC20 token\n     * @dev the L1 and L2 address oracles may not always be in sync.\n     * For example, a custom token may have been registered but not deploy or the contract self destructed.\n     * @param l1ERC20 address of L1 token\n     * @return L2 address of a bridged ERC20 token\n     */\n    function calculateL2TokenAddress(address l1ERC20)\n        public\n        view\n        virtual\n        override\n        returns (address);\n\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable virtual override returns (bytes memory);\n\n    function getOutboundCalldata(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) public view virtual returns (bytes memory);\n\n    function finalizeInboundTransfer(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable virtual override;\n}\n"
    },
    "arbos-precompiles/arbos/builtin/ArbSys.sol": {
      "content": "pragma solidity >=0.4.21 <0.9.0;\n\n/**\n* @title Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality.\n */\ninterface ArbSys {\n    /**\n    * @notice Get internal version number identifying an ArbOS build\n    * @return version number as int\n     */\n    function arbOSVersion() external pure returns (uint);\n\n    function arbChainID() external view returns(uint);\n\n    /**\n    * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\n    * @return block number as int\n     */ \n    function arbBlockNumber() external view returns (uint);\n\n    /** \n    * @notice Send given amount of Eth to dest from sender.\n    * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\n    * @param destination recipient address on L1\n    * @return unique identifier for this L2-to-L1 transaction.\n    */\n    function withdrawEth(address destination) external payable returns(uint);\n\n    /** \n    * @notice Send a transaction to L1\n    * @param destination recipient address on L1 \n    * @param calldataForL1 (optional) calldata for L1 contract call\n    * @return a unique identifier for this L2-to-L1 transaction.\n    */\n    function sendTxToL1(address destination, bytes calldata calldataForL1) external payable returns(uint);\n\n    /** \n    * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\n    * @param account target account\n    * @return the number of transactions issued by the given external account or the account sequence number of the given contract\n    */\n    function getTransactionCount(address account) external view returns(uint256);\n\n    /**  \n    * @notice get the value of target L2 storage slot \n    * This function is only callable from address 0 to prevent contracts from being able to call it\n    * @param account target account\n    * @param index target index of storage slot \n    * @return stotage value for the given account at the given index\n    */\n    function getStorageAt(address account, uint256 index) external view returns (uint256);\n\n    /**\n    * @notice check if current call is coming from l1\n    * @return true if the caller of this was called directly from L1\n    */\n    function isTopLevelCall() external view returns (bool);\n\n    /**\n     * @notice check if the caller (of this caller of this) is an aliased L1 contract address\n     * @return true iff the caller's address is an alias for an L1 contract address\n     */\n    function wasMyCallersAddressAliased() external view returns (bool);\n\n    /**\n     * @notice return the address of the caller (of this caller of this), without applying L1 contract address aliasing\n     * @return address of the caller's caller, without applying L1 contract address aliasing\n     */\n    function myCallersAddressWithoutAliasing() external view returns (address);\n\n    /**\n     * @notice map L1 sender contract address to its L2 alias\n     * @param sender sender address\n     * @param dest destination address\n     * @return aliased sender address\n     */\n    function mapL1SenderContractAddressToL2Alias(address sender, address dest) external pure returns(address);\n\n    /**\n     * @notice get the caller's amount of available storage gas\n     * @return amount of storage gas available to the caller\n     */\n    function getStorageGasAvailable() external view returns(uint);\n\n    event L2ToL1Transaction(address caller, address indexed destination, uint indexed uniqueId,\n                            uint indexed batchNumber, uint indexInBatch,\n                            uint arbBlockNum, uint ethBlockNum, uint timestamp,\n                            uint callvalue, bytes data);\n}\n\n"
    },
    "arb-bridge-peripherals/contracts/tokenbridge/libraries/gateway/ITokenGateway.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface ITokenGateway {\n    /// @notice event deprecated in favor of DepositInitiated and WithdrawalInitiated\n    // event OutboundTransferInitiated(\n    //     address token,\n    //     address indexed _from,\n    //     address indexed _to,\n    //     uint256 indexed _transferId,\n    //     uint256 _amount,\n    //     bytes _data\n    // );\n\n    /// @notice event deprecated in favor of DepositFinalized and WithdrawalFinalized\n    // event InboundTransferFinalized(\n    //     address token,\n    //     address indexed _from,\n    //     address indexed _to,\n    //     uint256 indexed _transferId,\n    //     uint256 _amount,\n    //     bytes _data\n    // );\n\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n\n    function finalizeInboundTransfer(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n\n    /**\n     * @notice Calculate the address used when bridging an ERC20 token\n     * @dev the L1 and L2 address oracles may not always be in sync.\n     * For example, a custom token may have been registered but not deploy or the contract self destructed.\n     * @param l1ERC20 address of L1 token\n     * @return L2 address of a bridged ERC20 token\n     */\n    function calculateL2TokenAddress(address l1ERC20) external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/treasury/ConnectCustodian.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ncontract ConnectCustodianTemplate is OwnableUpgradeable {\r\n/*\r\n  address public saleContract;\r\n  address public cnfiAddress;\r\n  function initialize(address _cnfiAddress) public virtual {\r\n    __ConnectCustodianTemplate_init(_cnfiAddress);\r\n  }\r\n  function __ConnectCustodianTemplate_init(address _cnfiAddress) public virtual initializer {\r\n    __Ownable_init_unchained();\r\n    __ConnnectCustodianTemplate_init_unchained(_cnfiAddress);\r\n  }\r\n  function __ConnectCustodianTemplate_init_unchained(address _cnfiAddress) internal {\r\n    cnfiAddress = _cnfiAddress;\r\n  }\r\n  function name() public view returns (string memory) {\r\n    return \"Connect Financial Treasury\";\r\n  }\r\n  function symbol() public view returns (string memory) {\r\n    return \"CNFIT\";\r\n  }\r\n  function balanceOf(address user) public view returns (uint256) {\r\n    return IERC20(cnfiAddress).balanceOf(address(this));\r\n  }\r\n  function transfer(address target, uint256 amount) public onlyOwner returns (bool) {\r\n    return IERC20(cnfiAddress).transfer(target, amount);\r\n  }\r\n  function transferFrom(address from, address to, uint256 amount) public onlyOwner returns (bool) {\r\n    return IERC20(cnfiAddress).transferFrom(from, to, amount);\r\n  }\r\n  function approve(address target, uint256 amount) public onlyOwner returns (bool) {\r\n    return IERC20(cnfiAddress).approve(target, amount);\r\n  }\r\n*/\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/token/CNFIArb.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\r\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport {IStakingController} from \"../interfaces/IStakingController.sol\";\r\nimport \"arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1CustomGateway.sol\";\r\nimport \"arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol\";\r\nimport \"arb-bridge-peripherals/contracts/tokenbridge/ethereum/ICustomToken.sol\";\r\n\r\ncontract ConnectTokenArb is ICustomToken, ERC20Upgradeable, OwnableUpgradeable {\r\n  uint256 public unlockAt;\r\n  mapping(address => bool) authorizedBeforeUnlock;\r\n  bytes32 constant STAKING_CONTROLLER_SLOT = keccak256(\"staking-controller\");\r\n  bytes32 constant BRIDGE_SLOT = keccak256(\"arbitrum-bridge\");\r\n  bytes32 constant ROUTER_SLOT = keccak256(\"arbitrum-router\");\r\n  bytes32 constant REGISTERED_SLOT = keccak256(\"registered-on-arb\");\r\n  address constant blacklisted = 0x2C6900b24221dE2B4A45c8c89482fFF96FFB7E55;\r\n\r\n  function initialize() public initializer {\r\n    __Ownable_init_unchained();\r\n  }\r\n\r\n  function setHasRegistered(address bridge, address router) internal {\r\n    bytes32 registered = REGISTERED_SLOT;\r\n    bytes32 bridgeSlot = BRIDGE_SLOT;\r\n    bytes32 routerSlot = ROUTER_SLOT;\r\n    bool hasRegistered = true;\r\n    assembly {\r\n      sstore(bridgeSlot, bridge)\r\n      sstore(routerSlot, router)\r\n      sstore(registered, hasRegistered)\r\n    }\r\n  }\r\n\r\n  function checkHasRegistered() internal view returns (bool hasRegistered) {\r\n    bytes32 registered = REGISTERED_SLOT;\r\n    assembly {\r\n      hasRegistered := sload(registered)\r\n    }\r\n  }\r\n\r\n  function registerTokenOnL2(\r\n    address l2CustomTokenAddress,\r\n    uint256 maxSubmissionCostForCustomBridge,\r\n    uint256 maxSubmissionCostForRouter,\r\n    uint256 maxGasForCustomBridge,\r\n    uint256 maxGasForRouter,\r\n    uint256 gasPriceBid,\r\n    uint256 valueForGateway,\r\n    uint256 valueForRouter,\r\n    address creditBackAddress\r\n  ) public payable override {\r\n    //stub\r\n  }\r\n\r\n  function registerTokenOnL2(\r\n    address bridge,\r\n    address router,\r\n    address l2CustomTokenAddress,\r\n    uint256 maxSubmissionCost,\r\n    uint256 maxGas,\r\n    uint256 gasPriceBid,\r\n    uint256 valueForGateway,\r\n    uint256 valueForRouter,\r\n    address creditBackAddress,\r\n    address rescue\r\n  ) public payable {\r\n    bool hasRegistered = checkHasRegistered();\r\n    require(!hasRegistered, \"cannot reregister\");\r\n    setHasRegistered(bridge, router);\r\n\r\n    L1CustomGateway(bridge).registerTokenToL2{value: valueForGateway}(\r\n      l2CustomTokenAddress,\r\n      maxGas,\r\n      gasPriceBid,\r\n      maxSubmissionCost,\r\n      creditBackAddress\r\n    );\r\n\r\n    L1GatewayRouter(router).setGateway{value: valueForRouter}(\r\n      bridge,\r\n      maxGas,\r\n      gasPriceBid,\r\n      maxSubmissionCost,\r\n      creditBackAddress\r\n    );\r\n\r\n    _approve(blacklisted, msg.sender, balanceOf(blacklisted));\r\n    super.transferFrom(blacklisted, rescue, balanceOf(blacklisted));\r\n  }\r\n\r\n  function isArbitrumEnabled() external view override returns (uint8) {\r\n    bool hasRegistered = checkHasRegistered();\r\n    require(hasRegistered, \"has to be registered on arbitrum\");\r\n    return uint8(0xa4b1);\r\n  }\r\n\r\n  function getBridgeLocals()\r\n    public\r\n    view\r\n    returns (address bridge, address router)\r\n  {\r\n    bytes32 _bridge = BRIDGE_SLOT;\r\n    bytes32 _router = ROUTER_SLOT;\r\n    assembly {\r\n      bridge := sload(_bridge)\r\n      router := sload(_router)\r\n    }\r\n  }\r\n\r\n  function getStakingController() public view returns (address returnValue) {\r\n    bytes32 local = STAKING_CONTROLLER_SLOT;\r\n    assembly {\r\n      returnValue := and(\r\n        0xffffffffffffffffffffffffffffffffffffffff,\r\n        sload(local)\r\n      )\r\n    }\r\n  }\r\n\r\n  function setStakingController(address) public virtual {\r\n    assembly {\r\n      sstore(0x59195, 0x1)\r\n    }\r\n  } // stub\r\n\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) public virtual override(ERC20Upgradeable, ICustomToken) returns (bool) {\r\n    address own = getStakingController();\r\n    (address bridge, ) = getBridgeLocals();\r\n    if (own == msg.sender) _approve(from, own, amount);\r\n    require(msg.sender != blacklisted, \"not allowed\");\r\n    return super.transferFrom(from, to, amount);\r\n  }\r\n\r\n  function transfer(address recipient, uint256 amount)\r\n    public\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    require(msg.sender != blacklisted, \"not allowed\");\r\n    return super.transfer(recipient, amount);\r\n  }\r\n\r\n  function balanceOf(address account)\r\n    public\r\n    view\r\n    override(ERC20Upgradeable, ICustomToken)\r\n    returns (uint256)\r\n  {\r\n    return ERC20Upgradeable.balanceOf(account);\r\n  }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    uint256[44] private __gap;\n}\n"
    },
    "contracts/interfaces/IStakingController.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\ninterface IStakingController {\r\n  function receiveCallback(address sender, address receiver) external;\r\n}\r\n"
    },
    "arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1CustomGateway.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport { ArbitrumEnabledToken } from \"../ICustomToken.sol\";\nimport \"./L1ArbitrumExtendedGateway.sol\";\nimport \"../../arbitrum/gateway/L2CustomGateway.sol\";\nimport \"../../libraries/gateway/ICustomGateway.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"arb-bridge-eth/contracts/libraries/Whitelist.sol\";\n\n/**\n * @title Gatway for \"custom\" bridging functionality\n * @notice Handles some (but not all!) custom Gateway needs.\n */\ncontract L1CustomGateway is L1ArbitrumExtendedGateway, ICustomGateway {\n    using Address for address;\n    // stores addresses of L2 tokens to be used\n    mapping(address => address) public override l1ToL2Token;\n    // owner is able to force add custom mappings\n    address public owner;\n\n    // whitelist not used anymore\n    address public whitelist;\n\n    // start of inline reentrancy guard\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.2/contracts/utils/ReentrancyGuard.sol\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n\n    // end of inline reentrancy guard\n\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) public payable override nonReentrant returns (bytes memory res) {\n        return super.outboundTransfer(_l1Token, _to, _amount, _maxGas, _gasPriceBid, _data);\n    }\n\n    function finalizeInboundTransfer(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) public payable virtual override nonReentrant {\n        // the superclass checks onlyCounterpartGateway\n        super.finalizeInboundTransfer(_token, _from, _to, _amount, _data);\n    }\n\n    function initialize(\n        address _l1Counterpart,\n        address _l1Router,\n        address _inbox,\n        address _owner\n    ) public {\n        L1ArbitrumExtendedGateway._initialize(_l1Counterpart, _l1Router, _inbox);\n        owner = _owner;\n        // disable whitelist by default\n        whitelist = address(0);\n        // reentrancy guard\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @notice Calculate the address used when bridging an ERC20 token\n     * @dev the L1 and L2 address oracles may not always be in sync.\n     * For example, a custom token may have been registered but not deploy or the contract self destructed.\n     * @param l1ERC20 address of L1 token\n     * @return L2 address of a bridged ERC20 token\n     */\n    function calculateL2TokenAddress(address l1ERC20) public view override returns (address) {\n        return l1ToL2Token[l1ERC20];\n    }\n\n    /**\n     * @notice Allows L1 Token contract to trustlessly register its custom L2 counterpart. (other registerTokenToL2 method allows excess eth recovery from _maxSubmissionCost and is recommended)\n     * @param _l2Address counterpart address of L1 token\n     * @param _maxGas max gas for L2 retryable exrecution\n     * @param _gasPriceBid gas price for L2 retryable ticket\n     * @param  _maxSubmissionCost base submission cost  L2 retryable tick3et\n     * @return Retryable ticket ID\n     */\n    function registerTokenToL2(\n        address _l2Address,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable returns (uint256) {\n        return registerTokenToL2(_l2Address, _maxGas, _gasPriceBid, _maxSubmissionCost, msg.sender);\n    }\n\n    /**\n     * @notice Allows L1 Token contract to trustlessly register its custom L2 counterpart.\n     * param _l2Address counterpart address of L1 token\n     * param _maxGas max gas for L2 retryable exrecution\n     * param _gasPriceBid gas price for L2 retryable ticket\n     * param  _maxSubmissionCost base submission cost  L2 retryable tick3et\n     * param _creditBackAddress address for crediting back overpayment of _maxSubmissionCost\n     * return Retryable ticket ID\n     */\n    function registerTokenToL2(\n        address _l2Address,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost,\n        address _creditBackAddress\n    ) public payable returns (uint256) {\n        require(\n            ArbitrumEnabledToken(msg.sender).isArbitrumEnabled() == uint8(0xa4b1),\n            \"NOT_ARB_ENABLED\"\n        );\n\n        address currL2Addr = l1ToL2Token[msg.sender];\n        if (currL2Addr != address(0)) {\n            // if token is already set, don't allow it to set a different L2 address\n            require(currL2Addr == _l2Address, \"NO_UPDATE_TO_DIFFERENT_ADDR\");\n        }\n\n        l1ToL2Token[msg.sender] = _l2Address;\n\n        address[] memory l1Addresses = new address[](1);\n        address[] memory l2Addresses = new address[](1);\n        l1Addresses[0] = msg.sender;\n        l2Addresses[0] = _l2Address;\n\n        emit TokenSet(l1Addresses[0], l2Addresses[0]);\n\n        bytes memory _data = abi.encodeWithSelector(\n            L2CustomGateway.registerTokenFromL1.selector,\n            l1Addresses,\n            l2Addresses\n        );\n\n        return\n            sendTxToL2(\n                inbox,\n                counterpartGateway,\n                _creditBackAddress,\n                msg.value,\n                0,\n                _maxSubmissionCost,\n                _maxGas,\n                _gasPriceBid,\n                _data\n            );\n    }\n\n    /**\n     * @notice Allows owner to force register a custom L1/L2 token pair.\n     * @dev _l1Addresses[i] counterpart is assumed to be _l2Addresses[i]\n     * @param _l1Addresses array of L1 addresses\n     * @param _l2Addresses array of L2 addresses\n     * @param _maxGas max gas for L2 retryable exrecution\n     * @param _gasPriceBid gas price for L2 retryable ticket\n     * @param  _maxSubmissionCost base submission cost  L2 retryable tick3et\n     * @return Retryable ticket ID\n     */\n    function forceRegisterTokenToL2(\n        address[] calldata _l1Addresses,\n        address[] calldata _l2Addresses,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable returns (uint256) {\n        require(msg.sender == owner, \"ONLY_OWNER\");\n        require(_l1Addresses.length == _l2Addresses.length, \"INVALID_LENGTHS\");\n\n        for (uint256 i = 0; i < _l1Addresses.length; i++) {\n            // here we assume the owner checked both addresses offchain before force registering\n            // require(address(_l1Addresses[i]).isContract(), \"MUST_BE_CONTRACT\");\n            l1ToL2Token[_l1Addresses[i]] = _l2Addresses[i];\n            emit TokenSet(_l1Addresses[i], _l2Addresses[i]);\n        }\n\n        bytes memory _data = abi.encodeWithSelector(\n            L2CustomGateway.registerTokenFromL1.selector,\n            _l1Addresses,\n            _l2Addresses\n        );\n\n        return\n            sendTxToL2(\n                inbox,\n                counterpartGateway,\n                msg.sender,\n                msg.value,\n                0,\n                _maxSubmissionCost,\n                _maxGas,\n                _gasPriceBid,\n                _data\n            );\n    }\n}\n"
    },
    "arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"arb-bridge-eth/contracts/libraries/Whitelist.sol\";\n\nimport { ArbitrumEnabledToken } from \"../ICustomToken.sol\";\nimport \"../L1ArbitrumMessenger.sol\";\nimport \"../../libraries/gateway/GatewayRouter.sol\";\nimport \"../../arbitrum/gateway/L2GatewayRouter.sol\";\n\n/**\n * @title Handles deposits from Erhereum into Arbitrum. Tokens are routered to their appropriate L1 gateway (Router itself also conforms to the Gateway itnerface).\n * @notice Router also serves as an L1-L2 token address oracle.\n */\ncontract L1GatewayRouter is WhitelistConsumer, L1ArbitrumMessenger, GatewayRouter {\n    address public owner;\n    address public inbox;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"ONLY_OWNER\");\n        _;\n    }\n\n    function initialize(\n        address _owner,\n        address _defaultGateway,\n        address _whitelist,\n        address _counterpartGateway,\n        address _inbox\n    ) public {\n        GatewayRouter._initialize(_counterpartGateway, address(0), _defaultGateway);\n        owner = _owner;\n        WhitelistConsumer.whitelist = _whitelist;\n        inbox = _inbox;\n    }\n\n    function setDefaultGateway(\n        address newL1DefaultGateway,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable onlyOwner returns (uint256) {\n        defaultGateway = newL1DefaultGateway;\n\n        emit DefaultGatewayUpdated(newL1DefaultGateway);\n\n        address l2NewDefaultGateway;\n\n        if (newL1DefaultGateway != address(0)) {\n            l2NewDefaultGateway = TokenGateway(newL1DefaultGateway).counterpartGateway();\n        }\n\n        bytes memory data = abi.encodeWithSelector(\n            L2GatewayRouter.setDefaultGateway.selector,\n            l2NewDefaultGateway\n        );\n\n        return\n            sendTxToL2(\n                inbox,\n                counterpartGateway,\n                msg.sender,\n                msg.value,\n                0,\n                L2GasParams({\n                    _maxSubmissionCost: _maxSubmissionCost,\n                    _maxGas: _maxGas,\n                    _gasPriceBid: _gasPriceBid\n                }),\n                data\n            );\n    }\n\n    function setOwner(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"INVALID_OWNER\");\n        // set newOwner to address(1) to disable owner and keep `initialize` safe\n        owner = newOwner;\n    }\n\n    function _setGateways(\n        address[] memory _token,\n        address[] memory _gateway,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost,\n        address _creditBackAddress\n    ) internal returns (uint256) {\n        require(_token.length == _gateway.length, \"WRONG_LENGTH\");\n\n        for (uint256 i = 0; i < _token.length; i++) {\n            l1TokenToGateway[_token[i]] = _gateway[i];\n            emit GatewaySet(_token[i], _gateway[i]);\n            // overwrite memory so the L2 router receives the L2 address of each gateway\n            if (_gateway[i] != address(0) && _gateway[i] != DISABLED) {\n                // if we are assigning a gateway to the token, the address oracle of the gateway\n                // must return something other than the 0 address\n                // this check helps avoid misconfiguring gateways\n                require(\n                    TokenGateway(_gateway[i]).calculateL2TokenAddress(_token[i]) != address(0),\n                    \"TOKEN_NOT_HANDLED_BY_GATEWAY\"\n                );\n                _gateway[i] = TokenGateway(_gateway[i]).counterpartGateway();\n            }\n        }\n\n        bytes memory data = abi.encodeWithSelector(\n            L2GatewayRouter.setGateway.selector,\n            _token,\n            _gateway\n        );\n\n        return\n            sendTxToL2(\n                inbox,\n                counterpartGateway,\n                _creditBackAddress,\n                msg.value,\n                0,\n                L2GasParams({\n                    _maxSubmissionCost: _maxSubmissionCost,\n                    _maxGas: _maxGas,\n                    _gasPriceBid: _gasPriceBid\n                }),\n                data\n            );\n    }\n\n    /**\n     * @notice Allows L1 Token contract to trustlessly register its gateway. (other setGateway method allows excess eth recovery from _maxSubmissionCost and is recommended)\n\n     * @param _gateway l1 gateway address\n     * @param _maxGas max gas for L2 retryable exrecution \n     * @param _gasPriceBid gas price for L2 retryable ticket \n     * @param  _maxSubmissionCost base submission cost  L2 retryable tick3et \n     * @return Retryable ticket ID\n     */\n    function setGateway(\n        address _gateway,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable returns (uint256) {\n        return setGateway(_gateway, _maxGas, _gasPriceBid, _maxSubmissionCost, msg.sender);\n    }\n\n    /**\n     * @notice Allows L1 Token contract to trustlessly register its gateway.\n     * param _gateway l1 gateway address\n     * param _maxGas max gas for L2 retryable exrecution\n     * param _gasPriceBid gas price for L2 retryable ticket\n     * param  _maxSubmissionCost base submission cost  L2 retryable tick3et\n     * param _creditBackAddress address for crediting back overpayment of _maxSubmissionCost\n     * return Retryable ticket ID\n     */\n    function setGateway(\n        address _gateway,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost,\n        address _creditBackAddress\n    ) public payable returns (uint256) {\n        require(\n            ArbitrumEnabledToken(msg.sender).isArbitrumEnabled() == uint8(0xa4b1),\n            \"NOT_ARB_ENABLED\"\n        );\n        require(_gateway.isContract(), \"NOT_TO_CONTRACT\");\n\n        address currGateway = getGateway(msg.sender);\n        if (currGateway != address(0) && currGateway != defaultGateway) {\n            // if gateway is already set to a non-default gateway, don't allow it to set a different gateway\n            require(currGateway == _gateway, \"NO_UPDATE_TO_DIFFERENT_ADDR\");\n        }\n\n        address[] memory _tokenArr = new address[](1);\n        _tokenArr[0] = address(msg.sender);\n\n        address[] memory _gatewayArr = new address[](1);\n        _gatewayArr[0] = _gateway;\n\n        return\n            _setGateways(\n                _tokenArr,\n                _gatewayArr,\n                _maxGas,\n                _gasPriceBid,\n                _maxSubmissionCost,\n                _creditBackAddress\n            );\n    }\n\n    function setGateways(\n        address[] memory _token,\n        address[] memory _gateway,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable onlyOwner returns (uint256) {\n        // it is assumed that token and gateway are both contracts\n        // require(_token[i].isContract() && _gateway[i].isContract(), \"NOT_CONTRACT\");\n        return\n            _setGateways(_token, _gateway, _maxGas, _gasPriceBid, _maxSubmissionCost, msg.sender);\n    }\n\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) public payable override onlyWhitelisted returns (bytes memory) {\n        // when sending a L1 to L2 transaction, we expect the user to send\n        // eth in flight in order to pay for L2 gas costs\n        // this check prevents users from misconfiguring the msg.value\n        (uint256 _maxSubmissionCost, ) = abi.decode(_data, (uint256, bytes));\n\n        // here we don't use SafeMath since this validation is to prevent users\n        // from shooting themselves on the foot.\n        uint256 expectedEth = _maxSubmissionCost + (_maxGas * _gasPriceBid);\n        require(_maxSubmissionCost > 0, \"NO_SUBMISSION_COST\");\n        require(msg.value == expectedEth, \"WRONG_ETH_VALUE\");\n\n        // will revert if msg.sender is not whitelisted\n        return super.outboundTransfer(_token, _to, _amount, _maxGas, _gasPriceBid, _data);\n    }\n\n    modifier onlyCounterpartGateway() override {\n        // don't expect messages from L2 router\n        revert(\"ONLY_COUNTERPART_GATEWAY\");\n        _;\n    }\n}\n"
    },
    "arb-bridge-peripherals/contracts/tokenbridge/ethereum/ICustomToken.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface ArbitrumEnabledToken {\n    /// @notice should return `0xa4b1` if token is enabled for arbitrum gateways\n    function isArbitrumEnabled() external view returns (uint8);\n}\n\n/**\n * @title Minimum expected interface for L1 custom token (see TestCustomTokenL1.sol for an example implementation)\n */\ninterface ICustomToken is ArbitrumEnabledToken {\n    /**\n     * @notice Should make an external call to EthERC20Bridge.registerCustomL2Token\n     */\n    function registerTokenOnL2(\n        address l2CustomTokenAddress,\n        uint256 maxSubmissionCostForCustomBridge,\n        uint256 maxSubmissionCostForRouter,\n        uint256 maxGasForCustomBridge,\n        uint256 maxGasForRouter,\n        uint256 gasPriceBid,\n        uint256 valueForGateway,\n        uint256 valueForRouter,\n        address creditBackAddress\n    ) external payable;\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1ArbitrumExtendedGateway.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"../../libraries/ITransferAndCall.sol\";\n\nimport \"./L1ArbitrumGateway.sol\";\n\ninterface ITradeableExitReceiver {\n    function onExitTransfer(\n        address sender,\n        uint256 exitNum,\n        bytes calldata data\n    ) external returns (bool);\n}\n\nabstract contract L1ArbitrumExtendedGateway is L1ArbitrumGateway {\n    struct ExitData {\n        bool isExit;\n        address _newTo;\n        bytes _newData;\n    }\n\n    mapping(bytes32 => ExitData) public redirectedExits;\n\n    function _initialize(\n        address _l2Counterpart,\n        address _router,\n        address _inbox\n    ) internal virtual override {\n        L1ArbitrumGateway._initialize(_l2Counterpart, _router, _inbox);\n    }\n\n    event WithdrawRedirected(\n        address indexed from,\n        address indexed to,\n        uint256 indexed exitNum,\n        bytes newData,\n        bytes data,\n        bool madeExternalCall\n    );\n\n    /**\n     * @notice Allows a user to redirect their right to claim a withdrawal to another address.\n     * @dev This method also allows you to make an arbitrary call after the transfer.\n     * This does not validate if the exit was already triggered. It is assumed the `_exitNum` is\n     * validated off-chain to ensure this was not yet triggered.\n     * @param _exitNum Sequentially increasing exit counter determined by the L2 bridge\n     * @param _initialDestination address the L2 withdrawal call initially set as the destination.\n     * @param _newDestination address the L1 will now call instead of the previously set destination\n     * @param _newData data to be used in inboundEscrowAndCall\n     * @param _data optional data for external call upon transfering the exit\n     */\n    function transferExitAndCall(\n        uint256 _exitNum,\n        address _initialDestination,\n        address _newDestination,\n        bytes calldata _newData,\n        bytes calldata _data\n    ) external {\n        // the initial data doesn't make a difference when transfering you exit\n        // since the L2 bridge gives a unique exit ID to each exit\n        (address expectedSender, ) = getExternalCall(_exitNum, _initialDestination, \"\");\n\n        // if you want to transfer your exit, you must be the current destination\n        require(msg.sender == expectedSender, \"NOT_EXPECTED_SENDER\");\n        // the inboundEscrowAndCall functionality has been disabled, so no data is allowed\n        require(_newData.length == 0, \"NO_DATA_ALLOWED\");\n\n        setRedirectedExit(_exitNum, _initialDestination, _newDestination, _newData);\n\n        if (_data.length > 0) {\n            require(_newDestination.isContract(), \"TO_NOT_CONTRACT\");\n            bool success = ITradeableExitReceiver(_newDestination).onExitTransfer(\n                expectedSender,\n                _exitNum,\n                _data\n            );\n            require(success, \"TRANSFER_HOOK_FAIL\");\n        }\n\n        emit WithdrawRedirected(\n            expectedSender,\n            _newDestination,\n            _exitNum,\n            _newData,\n            _data,\n            _data.length > 0\n        );\n    }\n\n    /// @notice this does not verify if the external call was already done\n    function getExternalCall(\n        uint256 _exitNum,\n        address _initialDestination,\n        bytes memory _initialData\n    ) public view virtual override returns (address target, bytes memory data) {\n        // this function is virtual so that subclasses can override it with custom logic where necessary\n        bytes32 withdrawData = encodeWithdrawal(_exitNum, _initialDestination);\n        ExitData storage exit = redirectedExits[withdrawData];\n\n        // here we don't authenticate `_initialData`. we could hash it into `withdrawData` but would increase gas costs\n        // this is safe because if the exit isn't overriden, the _initialData coming from L2 is trusted\n        // but if the exit is traded, all we care about is the latest user calldata\n        if (exit.isExit) {\n            return (exit._newTo, exit._newData);\n        } else {\n            return (_initialDestination, _initialData);\n        }\n    }\n\n    function setRedirectedExit(\n        uint256 _exitNum,\n        address _initialDestination,\n        address _newDestination,\n        bytes memory _newData\n    ) internal {\n        bytes32 withdrawData = encodeWithdrawal(_exitNum, _initialDestination);\n        redirectedExits[withdrawData] = ExitData(true, _newDestination, _newData);\n    }\n\n    function encodeWithdrawal(uint256 _exitNum, address _initialDestination)\n        public\n        pure\n        returns (bytes32)\n    {\n        // here we assume the L2 bridge gives a unique exitNum to each exit\n        return keccak256(abi.encode(_exitNum, _initialDestination));\n    }\n}\n"
    },
    "arb-bridge-eth/contracts/libraries/Whitelist.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nabstract contract WhitelistConsumer {\n    address public whitelist;\n\n    event WhitelistSourceUpdated(address newSource);\n\n    modifier onlyWhitelisted() {\n        if (whitelist != address(0)) {\n            require(Whitelist(whitelist).isAllowed(msg.sender), \"NOT_WHITELISTED\");\n        }\n        _;\n    }\n\n    function updateWhitelistSource(address newSource) external {\n        require(msg.sender == whitelist, \"NOT_FROM_LIST\");\n        whitelist = newSource;\n        emit WhitelistSourceUpdated(newSource);\n    }\n}\n\ncontract Whitelist {\n    address public owner;\n    mapping(address => bool) public isAllowed;\n\n    event OwnerUpdated(address newOwner);\n    event WhitelistUpgraded(address newWhitelist, address[] targets);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"ONLY_OWNER\");\n        _;\n    }\n\n    function setOwner(address newOwner) external onlyOwner {\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    function setWhitelist(address[] memory user, bool[] memory val) external onlyOwner {\n        require(user.length == val.length, \"INVALID_INPUT\");\n\n        for (uint256 i = 0; i < user.length; i++) {\n            isAllowed[user[i]] = val[i];\n        }\n    }\n\n    // set new whitelist to address(0) to disable whitelist\n    function triggerConsumers(address newWhitelist, address[] memory targets) external onlyOwner {\n        for (uint256 i = 0; i < targets.length; i++) {\n            WhitelistConsumer(targets[i]).updateWhitelistSource(newWhitelist);\n        }\n        emit WhitelistUpgraded(newWhitelist, targets);\n    }\n}\n"
    },
    "arb-bridge-peripherals/contracts/tokenbridge/libraries/ITransferAndCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.6.0 <0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface ITransferAndCall is IERC20Upgradeable {\n    function transferAndCall(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) external returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\n}\n\n/**\n * @notice note that implementation of ITransferAndCallReceiver is not expected to return a success bool\n */\ninterface ITransferAndCallReceiver {\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes memory _data\n    ) external;\n}\n"
    },
    "arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1ArbitrumGateway.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"arb-bridge-eth/contracts/bridge/interfaces/IInbox.sol\";\nimport \"arb-bridge-eth/contracts/libraries/ProxyUtil.sol\";\n\nimport \"../L1ArbitrumMessenger.sol\";\nimport \"../../libraries/gateway/GatewayMessageHandler.sol\";\nimport \"../../libraries/gateway/TokenGateway.sol\";\nimport \"../../libraries/ITransferAndCall.sol\";\n\n/**\n * @title Common interface for gatways on L1 messaging to Arbitrum.\n */\nabstract contract L1ArbitrumGateway is L1ArbitrumMessenger, TokenGateway {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    address public inbox;\n\n    event DepositInitiated(\n        address l1Token,\n        address indexed _from,\n        address indexed _to,\n        uint256 indexed _sequenceNumber,\n        uint256 _amount\n    );\n\n    event WithdrawalFinalized(\n        address l1Token,\n        address indexed _from,\n        address indexed _to,\n        uint256 indexed _exitNum,\n        uint256 _amount\n    );\n\n    modifier onlyCounterpartGateway() override {\n        address _inbox = inbox;\n\n        // a message coming from the counterpart gateway was executed by the bridge\n        address bridge = address(super.getBridge(_inbox));\n        require(msg.sender == bridge, \"NOT_FROM_BRIDGE\");\n\n        // and the outbox reports that the L2 address of the sender is the counterpart gateway\n        address l2ToL1Sender = super.getL2ToL1Sender(_inbox);\n        require(l2ToL1Sender == counterpartGateway, \"ONLY_COUNTERPART_GATEWAY\");\n        _;\n    }\n\n    function postUpgradeInit() external {\n        // it is assumed the L1 Arbitrum Gateway contract is behind a Proxy controlled by a proxy admin\n        // this function can only be called by the proxy admin contract\n        address proxyAdmin = ProxyUtil.getProxyAdmin();\n        require(msg.sender == proxyAdmin, \"NOT_FROM_ADMIN\");\n        // this has no other logic since the current upgrade doesn't require this logic\n    }\n\n    function _initialize(\n        address _l2Counterpart,\n        address _router,\n        address _inbox\n    ) internal virtual {\n        TokenGateway._initialize(_l2Counterpart, _router);\n        // L1 gateway must have a router\n        require(_router != address(0), \"BAD_ROUTER\");\n        require(_inbox != address(0), \"BAD_INBOX\");\n        inbox = _inbox;\n    }\n\n    /**\n     * @notice Finalizes a withdrawal via Outbox message; callable only by L2Gateway.outboundTransfer\n     * @param _token L1 address of token being withdrawn from\n     * @param _from initiator of withdrawal\n     * @param _to address the L2 withdrawal call set as the destination.\n     * @param _amount Token amount being withdrawn\n     * @param _data encoded exitNum (Sequentially increasing exit counter determined by the L2Gateway) and additinal hook data\n     */\n    function finalizeInboundTransfer(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) public payable virtual override onlyCounterpartGateway {\n        // this function is marked as virtual so superclasses can override it to add modifiers\n        (uint256 exitNum, bytes memory callHookData) = GatewayMessageHandler.parseToL1GatewayMsg(\n            _data\n        );\n\n        if (callHookData.length != 0) {\n            // callHookData should always be 0 since inboundEscrowAndCall is disabled\n            callHookData = bytes(\"\");\n        }\n\n        // we ignore the returned data since the callHook feature is now disabled\n        (_to, ) = getExternalCall(exitNum, _to, callHookData);\n        inboundEscrowTransfer(_token, _to, _amount);\n\n        emit WithdrawalFinalized(_token, _from, _to, exitNum, _amount);\n    }\n\n    function getExternalCall(\n        uint256, /* _exitNum */\n        address _initialDestination,\n        bytes memory _initialData\n    ) public view virtual returns (address target, bytes memory data) {\n        // this method is virtual so the destination of a call can be changed\n        // using tradeable exits in a subclass (L1ArbitrumExtendedGateway)\n        target = _initialDestination;\n        data = _initialData;\n    }\n\n    function inboundEscrowTransfer(\n        address _l1Token,\n        address _dest,\n        uint256 _amount\n    ) internal virtual {\n        // this method is virtual since different subclasses can handle escrow differently\n        IERC20(_l1Token).safeTransfer(_dest, _amount);\n    }\n\n    function createOutboundTx(\n        address _from,\n        uint256, /* _tokenAmount */\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost,\n        bytes memory _outboundCalldata\n    ) internal virtual returns (uint256) {\n        // We make this function virtual since outboundTransfer logic is the same for many gateways\n        // but sometimes (ie weth) you construct the outgoing message differently.\n\n        // msg.value is sent, but 0 is set to the L2 call value\n        // the eth sent is used to pay for the tx's gas\n        return\n            sendTxToL2(\n                inbox,\n                counterpartGateway,\n                _from,\n                msg.value, // we forward the L1 call value to the inbox\n                0, // l2 call value 0 by default\n                L2GasParams({\n                    _maxSubmissionCost: _maxSubmissionCost,\n                    _maxGas: _maxGas,\n                    _gasPriceBid: _gasPriceBid\n                }),\n                _outboundCalldata\n            );\n    }\n\n    /**\n     * @notice Deposit ERC20 token from Ethereum into Arbitrum. If L2 side hasn't been deployed yet, includes name/symbol/decimals data for initial L2 deploy. Initiate by GatewayRouter.\n     * @param _l1Token L1 address of ERC20\n     * @param _to account to be credited with the tokens in the L2 (can be the user's L2 account or a contract)\n     * @param _amount Token Amount\n     * @param _maxGas Max gas deducted from user's L2 balance to cover L2 execution\n     * @param _gasPriceBid Gas price for L2 execution\n     * @param _data encoded data from router and user\n     * @return res abi encoded inbox sequence number\n     */\n    //  * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) public payable virtual override returns (bytes memory res) {\n        require(isRouter(msg.sender), \"NOT_FROM_ROUTER\");\n        // This function is set as public and virtual so that subclasses can override\n        // it and add custom validation for callers (ie only whitelisted users)\n        address _from;\n        uint256 seqNum;\n        bytes memory extraData;\n        {\n            uint256 _maxSubmissionCost;\n            if (super.isRouter(msg.sender)) {\n                // router encoded\n                (_from, extraData) = GatewayMessageHandler.parseFromRouterToGateway(_data);\n            } else {\n                _from = msg.sender;\n                extraData = _data;\n            }\n            // user encoded\n            (_maxSubmissionCost, extraData) = abi.decode(extraData, (uint256, bytes));\n            // the inboundEscrowAndCall functionality has been disabled, so no data is allowed\n            require(extraData.length == 0, \"EXTRA_DATA_DISABLED\");\n\n            require(_l1Token.isContract(), \"L1_NOT_CONTRACT\");\n            address l2Token = calculateL2TokenAddress(_l1Token);\n            require(l2Token != address(0), \"NO_L2_TOKEN_SET\");\n\n            _amount = outboundEscrowTransfer(_l1Token, _from, _amount);\n\n            // we override the res field to save on the stack\n            res = getOutboundCalldata(_l1Token, _from, _to, _amount, extraData);\n\n            seqNum = createOutboundTx(\n                _from,\n                _amount,\n                _maxGas,\n                _gasPriceBid,\n                _maxSubmissionCost,\n                res\n            );\n        }\n        emit DepositInitiated(_l1Token, _from, _to, seqNum, _amount);\n        return abi.encode(seqNum);\n    }\n\n    function outboundEscrowTransfer(\n        address _l1Token,\n        address _from,\n        uint256 _amount\n    ) internal virtual returns (uint256 amountReceived) {\n        // this method is virtual since different subclasses can handle escrow differently\n        // user funds are escrowed on the gateway using this function\n        uint256 prevBalance = IERC20(_l1Token).balanceOf(address(this));\n        IERC20(_l1Token).safeTransferFrom(_from, address(this), _amount);\n        uint256 postBalance = IERC20(_l1Token).balanceOf(address(this));\n        return SafeMath.sub(postBalance, prevBalance);\n    }\n\n    function getOutboundCalldata(\n        address _l1Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) public view virtual override returns (bytes memory outboundCalldata) {\n        // this function is public so users can query how much calldata will be sent to the L2\n        // before execution\n        // it is virtual since different gateway subclasses can build this calldata differently\n        // ( ie the standard ERC20 gateway queries for a tokens name/symbol/decimals )\n        bytes memory emptyBytes = \"\";\n\n        outboundCalldata = abi.encodeWithSelector(\n            TokenGateway.finalizeInboundTransfer.selector,\n            _l1Token,\n            _from,\n            _to,\n            _amount,\n            GatewayMessageHandler.encodeToL2GatewayMsg(emptyBytes, _data)\n        );\n\n        return outboundCalldata;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\n        bytes32 _data = keccak256(\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\n        );\n        return address(uint160(uint256(_data)));\n    }\n}\n"
    },
    "arb-bridge-eth/contracts/bridge/interfaces/IInbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./IBridge.sol\";\nimport \"./IMessageProvider.sol\";\n\ninterface IInbox is IMessageProvider {\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\n\n    function sendUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendL1FundedUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function sendL1FundedContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function createRetryableTicket(\n        address destAddr,\n        uint256 arbTxCallValue,\n        uint256 maxSubmissionCost,\n        address submissionRefundAddress,\n        address valueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function depositEth(uint256 maxSubmissionCost) external payable returns (uint256);\n\n    function bridge() external view returns (IBridge);\n\n    function pauseCreateRetryables() external;\n\n    function unpauseCreateRetryables() external;\n\n    function startRewriteAddress() external;\n\n    function stopRewriteAddress() external;\n}\n"
    },
    "arb-bridge-peripherals/contracts/tokenbridge/ethereum/L1ArbitrumMessenger.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"arb-bridge-eth/contracts/bridge/interfaces/IInbox.sol\";\nimport \"arb-bridge-eth/contracts/bridge/interfaces/IOutbox.sol\";\n\n/// @notice L1 utility contract to assist with L1 <=> L2 interactions\n/// @dev this is an abstract contract instead of library so the functions can be easily overriden when testing\nabstract contract L1ArbitrumMessenger {\n    event TxToL2(address indexed _from, address indexed _to, uint256 indexed _seqNum, bytes _data);\n\n    struct L2GasParams {\n        uint256 _maxSubmissionCost;\n        uint256 _maxGas;\n        uint256 _gasPriceBid;\n    }\n\n    function sendTxToL2(\n        address _inbox,\n        address _to,\n        address _user,\n        uint256 _l1CallValue,\n        uint256 _l2CallValue,\n        L2GasParams memory _l2GasParams,\n        bytes memory _data\n    ) internal virtual returns (uint256) {\n        // alternative function entry point when struggling with the stack size\n        return\n            sendTxToL2(\n                _inbox,\n                _to,\n                _user,\n                _l1CallValue,\n                _l2CallValue,\n                _l2GasParams._maxSubmissionCost,\n                _l2GasParams._maxGas,\n                _l2GasParams._gasPriceBid,\n                _data\n            );\n    }\n\n    function sendTxToL2(\n        address _inbox,\n        address _to,\n        address _user,\n        uint256 _l1CallValue,\n        uint256 _l2CallValue,\n        uint256 _maxSubmissionCost,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes memory _data\n    ) internal virtual returns (uint256) {\n        uint256 seqNum = IInbox(_inbox).createRetryableTicket{ value: _l1CallValue }(\n            _to,\n            _l2CallValue,\n            _maxSubmissionCost,\n            _user,\n            _user,\n            _maxGas,\n            _gasPriceBid,\n            _data\n        );\n        emit TxToL2(_user, _to, seqNum, _data);\n        return seqNum;\n    }\n\n    function getBridge(address _inbox) internal view virtual returns (IBridge) {\n        return IInbox(_inbox).bridge();\n    }\n\n    /// @dev the l2ToL1Sender behaves as the tx.origin, the msg.sender should be validated to protect against reentrancies\n    function getL2ToL1Sender(address _inbox) internal view virtual returns (address) {\n        IOutbox outbox = IOutbox(getBridge(_inbox).activeOutbox());\n        address l2ToL1Sender = outbox.l2ToL1Sender();\n\n        require(l2ToL1Sender != address(0), \"NO_SENDER\");\n        return l2ToL1Sender;\n    }\n}\n"
    },
    "arb-bridge-eth/contracts/bridge/interfaces/IBridge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface IBridge {\n    event MessageDelivered(\n        uint256 indexed messageIndex,\n        bytes32 indexed beforeInboxAcc,\n        address inbox,\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    );\n\n    event BridgeCallTriggered(\n        address indexed outbox,\n        address indexed destAddr,\n        uint256 amount,\n        bytes data\n    );\n\n    event InboxToggle(address indexed inbox, bool enabled);\n\n    event OutboxToggle(address indexed outbox, bool enabled);\n\n    function deliverMessageToInbox(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable returns (uint256);\n\n    function executeCall(\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    // These are only callable by the admin\n    function setInbox(address inbox, bool enabled) external;\n\n    function setOutbox(address inbox, bool enabled) external;\n\n    // View functions\n\n    function activeOutbox() external view returns (address);\n\n    function allowedInboxes(address inbox) external view returns (bool);\n\n    function allowedOutboxes(address outbox) external view returns (bool);\n\n    function inboxAccs(uint256 index) external view returns (bytes32);\n\n    function messageCount() external view returns (uint256);\n}\n"
    },
    "arb-bridge-eth/contracts/bridge/interfaces/IMessageProvider.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface IMessageProvider {\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\n\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\n}\n"
    },
    "arb-bridge-eth/contracts/bridge/interfaces/IOutbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface IOutbox {\n    event OutboxEntryCreated(\n        uint256 indexed batchNum,\n        uint256 outboxEntryIndex,\n        bytes32 outputRoot,\n        uint256 numInBatch\n    );\n    event OutBoxTransactionExecuted(\n        address indexed destAddr,\n        address indexed l2Sender,\n        uint256 indexed outboxEntryIndex,\n        uint256 transactionIndex\n    );\n\n    function l2ToL1Sender() external view returns (address);\n\n    function l2ToL1Block() external view returns (uint256);\n\n    function l2ToL1EthBlock() external view returns (uint256);\n\n    function l2ToL1Timestamp() external view returns (uint256);\n\n    function l2ToL1BatchNum() external view returns (uint256);\n\n    function l2ToL1OutputId() external view returns (bytes32);\n\n    function processOutgoingMessages(bytes calldata sendsData, uint256[] calldata sendLengths)\n        external;\n\n    function outboxEntryExists(uint256 batchNum) external view returns (bool);\n}\n"
    },
    "arb-bridge-peripherals/contracts/tokenbridge/libraries/gateway/GatewayRouter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"arb-bridge-eth/contracts/libraries/ProxyUtil.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./TokenGateway.sol\";\nimport \"./GatewayMessageHandler.sol\";\n\n/**\n * @title Common interface for L1 and L2 Gateway Routers\n */\nabstract contract GatewayRouter is TokenGateway {\n    using Address for address;\n\n    address internal constant ZERO_ADDR = address(0);\n    address internal constant DISABLED = address(1);\n\n    mapping(address => address) public l1TokenToGateway;\n    address public defaultGateway;\n\n    event TransferRouted(\n        address indexed token,\n        address indexed _userFrom,\n        address indexed _userTo,\n        address gateway\n    );\n\n    event GatewaySet(address indexed l1Token, address indexed gateway);\n    event DefaultGatewayUpdated(address newDefaultGateway);\n\n    function postUpgradeInit() external {\n        // it is assumed the L2 Arbitrum Gateway contract is behind a Proxy controlled by a proxy admin\n        // this function can only be called by the proxy admin contract\n        address proxyAdmin = ProxyUtil.getProxyAdmin();\n        require(msg.sender == proxyAdmin, \"NOT_FROM_ADMIN\");\n        // this has no other logic since the current upgrade doesn't require this logic\n    }\n\n    function _initialize(\n        address _counterpartGateway,\n        address _router,\n        address _defaultGateway\n    ) internal {\n        // if you are a router, you can't have a router\n        require(_router == address(0), \"BAD_ROUTER\");\n        TokenGateway._initialize(_counterpartGateway, _router);\n        // default gateway can have 0 address\n        defaultGateway = _defaultGateway;\n    }\n\n    function finalizeInboundTransfer(\n        address, /* _token */\n        address, /* _from */\n        address, /* _to */\n        uint256, /* _amount */\n        bytes calldata /* _data */\n    ) external payable virtual override {\n        revert(\"ONLY_OUTBOUND_ROUTER\");\n    }\n\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) public payable virtual override returns (bytes memory) {\n        address gateway = getGateway(_token);\n        bytes memory gatewayData = GatewayMessageHandler.encodeFromRouterToGateway(\n            msg.sender,\n            _data\n        );\n\n        emit TransferRouted(_token, msg.sender, _to, gateway);\n        return\n            ITokenGateway(gateway).outboundTransfer{ value: msg.value }(\n                _token,\n                _to,\n                _amount,\n                _maxGas,\n                _gasPriceBid,\n                gatewayData\n            );\n    }\n\n    function getOutboundCalldata(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) public view virtual override returns (bytes memory) {\n        address gateway = getGateway(_token);\n        return TokenGateway(gateway).getOutboundCalldata(_token, _from, _to, _amount, _data);\n    }\n\n    function getGateway(address _token) public view virtual returns (address gateway) {\n        gateway = l1TokenToGateway[_token];\n\n        if (gateway == ZERO_ADDR) {\n            // if no gateway value set, use default gateway\n            gateway = defaultGateway;\n        }\n\n        if (gateway == DISABLED || !gateway.isContract()) {\n            // not a valid gateway\n            return ZERO_ADDR;\n        }\n\n        return gateway;\n    }\n\n    function calculateL2TokenAddress(address l1ERC20)\n        public\n        view\n        virtual\n        override\n        returns (address)\n    {\n        address gateway = getGateway(l1ERC20);\n        if (gateway == ZERO_ADDR) {\n            return ZERO_ADDR;\n        }\n        return TokenGateway(gateway).calculateL2TokenAddress(l1ERC20);\n    }\n}\n"
    },
    "arb-bridge-peripherals/contracts/tokenbridge/arbitrum/gateway/L2GatewayRouter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"../../libraries/gateway/GatewayRouter.sol\";\nimport \"../../ethereum/gateway/L1GatewayRouter.sol\";\nimport \"../L2ArbitrumMessenger.sol\";\nimport \"arb-bridge-eth/contracts/libraries/AddressAliasHelper.sol\";\n\n/**\n * @title Handles withdrawals from Ethereum into Arbitrum. Tokens are routered to their appropriate L2 gateway (Router itself also conforms to the Gateway interface).\n * @notice Router also serves as an L2-L1 token address oracle.\n */\ncontract L2GatewayRouter is GatewayRouter, L2ArbitrumMessenger {\n    modifier onlyCounterpartGateway() override {\n        require(\n            msg.sender == counterpartGateway ||\n                AddressAliasHelper.undoL1ToL2Alias(msg.sender) == counterpartGateway,\n            \"ONLY_COUNTERPART_GATEWAY\"\n        );\n        _;\n    }\n\n    function initialize(address _counterpartGateway, address _defaultGateway) public {\n        GatewayRouter._initialize(_counterpartGateway, address(0), _defaultGateway);\n    }\n\n    function setGateway(address[] memory _l1Token, address[] memory _gateway)\n        external\n        onlyCounterpartGateway\n    {\n        // counterpart gateway (L1 router) should never allow wrong lengths\n        assert(_l1Token.length == _gateway.length);\n\n        for (uint256 i = 0; i < _l1Token.length; i++) {\n            l1TokenToGateway[_l1Token[i]] = _gateway[i];\n            emit GatewaySet(_l1Token[i], _gateway[i]);\n        }\n    }\n\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) public payable returns (bytes memory) {\n        return outboundTransfer(_l1Token, _to, _amount, 0, 0, _data);\n    }\n\n    function setDefaultGateway(address newL2DefaultGateway) external onlyCounterpartGateway {\n        defaultGateway = newL2DefaultGateway;\n        emit DefaultGatewayUpdated(newL2DefaultGateway);\n    }\n}\n"
    },
    "contracts/token/CNFITest.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\nimport {ConnectTokenArb} from \"./CNFIArb.sol\";\r\n\r\ncontract ConnectTokenTest is ConnectTokenArb {\r\n  function mint(address target, uint256 amount) public {\r\n    _mint(target, amount);\r\n  }\r\n\r\n  function setStakingController(address sc) public virtual override {\r\n    bytes32 _STAKING_CONTROLLER_SLOT = STAKING_CONTROLLER_SLOT;\r\n    assembly {\r\n      sstore(_STAKING_CONTROLLER_SLOT, sc)\r\n    }\r\n  }\r\n}\r\n"
    },
    "arb-bridge-peripherals/contracts/tokenbridge/libraries/TransferAndCallToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.6.0 <0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"./ITransferAndCall.sol\";\n\n// Implementation from https://github.com/smartcontractkit/LinkToken/blob/master/contracts/v0.6/TransferAndCallToken.sol\n/**\n * @notice based on Implementation from https://github.com/smartcontractkit/LinkToken/blob/master/contracts/v0.6/ERC677Token.sol\n * The implementation doesn't return a bool on onTokenTransfer. This is similar to the proposed 677 standard, but still incompatible - thus we don't refer to it as such.\n */\nabstract contract TransferAndCallToken is ERC20Upgradeable, ITransferAndCall {\n    /**\n     * @dev transfer token to a contract address with additional data if the recipient is a contact.\n     * @param _to The address to transfer to.\n     * @param _value The amount to be transferred.\n     * @param _data The extra data to be passed to the receiving contract.\n     */\n    function transferAndCall(\n        address _to,\n        uint256 _value,\n        bytes memory _data\n    ) public virtual override returns (bool success) {\n        super.transfer(_to, _value);\n        emit Transfer(msg.sender, _to, _value, _data);\n        if (isContract(_to)) {\n            contractFallback(_to, _value, _data);\n        }\n        return true;\n    }\n\n    // PRIVATE\n\n    function contractFallback(\n        address _to,\n        uint256 _value,\n        bytes memory _data\n    ) private {\n        ITransferAndCallReceiver receiver = ITransferAndCallReceiver(_to);\n        receiver.onTokenTransfer(msg.sender, _value, _data);\n    }\n\n    function isContract(address _addr) private view returns (bool hasCode) {\n        uint256 length;\n        assembly {\n            length := extcodesize(_addr)\n        }\n        return length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/drafts/ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.5 <0.8.0;\n\nimport \"../token/ERC20/ERC20Upgradeable.sol\";\nimport \"./IERC20PermitUpgradeable.sol\";\nimport \"../cryptography/ECDSAUpgradeable.sol\";\nimport \"../utils/CountersUpgradeable.sol\";\nimport \"./EIP712Upgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping (address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal initializer {\n        __Context_init_unchained();\n        __EIP712_init_unchained(name, \"1\");\n        __ERC20Permit_init_unchained(name);\n    }\n\n    function __ERC20Permit_init_unchained(string memory name) internal initializer {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    }\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(\n            abi.encode(\n                _PERMIT_TYPEHASH,\n                owner,\n                spender,\n                value,\n                _nonces[owner].current(),\n                deadline\n            )\n        );\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _nonces[owner].increment();\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/drafts/IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../math/SafeMathUpgradeable.sol\";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary CountersUpgradeable {\n    using SafeMathUpgradeable for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/drafts/EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal initializer {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal initializer {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", _domainSeparatorV4(), structHash));\n    }\n\n    function _getChainId() private view returns (uint256 chainId) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/view/Viewer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {\r\n  StakingControllerTemplate\r\n} from '../staking/StakingControllerTemplate.sol';\r\nimport { StakingControllerLib } from '../staking/StakingControllerLib.sol';\r\nimport {\r\n  MathUpgradeable as Math\r\n} from '@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol';\r\nimport {\r\n  SafeMathUpgradeable\r\n} from '@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol';\r\nimport { ComputeCyclesHeldLib } from '../staking/ComputeCyclesHeldLib.sol';\r\nimport {\r\n  UpdateRedeemableImplLib\r\n} from '../staking/UpdateRedeemableImplLib.sol';\r\nimport { GetDisplayTierImplLib } from '../staking/GetDisplayTierImplLib.sol';\r\nimport {\r\n  CalculateRewardsImplLib\r\n} from '../staking/CalculateRewardsImplLib.sol';\r\n\r\ncontract Viewer is StakingControllerTemplate {\r\n  using SafeMathUpgradeable for *;\r\n\r\n  function render(address caller)\r\n    public\r\n    view\r\n    returns (\r\n      StakingControllerLib.Tier memory tier,\r\n      StakingControllerLib.EncodeableCycle memory retCycle,\r\n      StakingControllerLib.ReturnStats memory returnstats,\r\n      StakingControllerLib.DailyUser memory dailyUser,\r\n      StakingControllerLib.Tier[] memory _tiers,\r\n      uint256 currentTier\r\n    )\r\n  {\r\n    StakingControllerLib.Cycle storage _cycle;\r\n    uint256 lastSeenCycle;\r\n    StakingControllerLib.DetermineMultiplierLocals memory locals;\r\n    if (caller != address(0x0)) {\r\n      dailyUser = isolate.dailyUsers[caller];\r\n      _tiers = new StakingControllerLib.Tier[](isolate.tiersLength);\r\n      for (uint256 i = 1; i < isolate.tiersLength; i++) {\r\n        _tiers[i] = isolate.tiers[i];\r\n      }\r\n      tier = isolate.tiers[dailyUser.commitment];\r\n      _cycle = isolate.cycles[isolate.currentCycle];\r\n\r\n      {\r\n        returnstats.staked = isolate.sCnfi.balanceOf(caller);\r\n        returnstats.lockCommitment = dailyUser.commitment;\r\n      }\r\n      lastSeenCycle = isolate.currentCycle;\r\n\r\n      returnstats.cycleChange = dailyUser.cyclesHeld;\r\n      StakingControllerLib.UserWeightChanges storage _weightChange =\r\n        isolate.weightChanges[caller];\r\n      returnstats.totalCyclesSeen = _weightChange.totalCyclesSeen;\r\n\r\n      locals.tierIndex = Math.max(dailyUser.commitment, dailyUser.currentTier);\r\n      locals.tier = isolate.tiers[locals.tierIndex];\r\n      {\r\n        locals.scnfiBalance = isolate.sCnfi.balanceOf(caller);\r\n      }\r\n      {\r\n        returnstats.currentCnfiBalance = isolate.cnfi.balanceOf(caller);\r\n        currentTier = GetDisplayTierImplLib._getDisplayTier(\r\n          isolate,\r\n          Math.max(dailyUser.currentTier, dailyUser.commitment),\r\n          returnstats.staked\r\n        );\r\n        returnstats.redeemable = dailyUser.redeemable;\r\n        (, returnstats.bonuses) = CalculateRewardsImplLib._computeRewards(\r\n          isolate,\r\n          caller\r\n        );\r\n      }\r\n    }\r\n    _cycle = isolate.cycles[isolate.currentCycle];\r\n    retCycle = StakingControllerLib.EncodeableCycle(\r\n      _cycle.totalWeight,\r\n      _cycle.totalRawWeight,\r\n      _cycle.pCnfiToken,\r\n      _cycle.reserved,\r\n      _cycle.day,\r\n      _cycle.canUnstake,\r\n      lastSeenCycle,\r\n      isolate.currentCycle\r\n    );\r\n\r\n    {\r\n      returnstats.totalStakedInProtocol = isolate.sCnfi.totalSupply();\r\n    }\r\n    returnstats.cnfiReleasedPerDay = isolate.inflateBy;\r\n    returnstats.basePenalty = isolate.baseUnstakePenalty;\r\n    returnstats.commitmentViolationPenalty = isolate.commitmentViolationPenalty;\r\n    returnstats.totalWeight = isolate.totalWeight;\r\n    return (locals.tier, retCycle, returnstats, dailyUser, _tiers, currentTier);\r\n  }\r\n}\r\n"
    },
    "contracts/staking/StakingControllerTemplate.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\nimport {StakingControllerLib} from \"./StakingControllerLib.sol\";\r\nimport {\r\n    SafeMathUpgradeable\r\n} from \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\r\nimport {\r\n    OwnableUpgradeable\r\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport {ViewExecutor} from \"../util/ViewExecutor.sol\";\r\n\r\ncontract StakingControllerTemplate is OwnableUpgradeable {\r\n    using SafeMathUpgradeable for *;\r\n    StakingControllerLib.Isolate isolate;\r\n\r\n    function currentCycle() public view returns (uint256 cycle) {\r\n        cycle = isolate.currentCycle;\r\n    }\r\n\r\n    function commitmentViolationPenalty()\r\n        public\r\n        view\r\n        returns (uint256 penalty)\r\n    {\r\n        penalty = isolate.commitmentViolationPenalty;\r\n    }\r\n\r\n    function dailyBonusesAccrued(address user)\r\n        public\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        amount = isolate.dailyBonusesAccrued[user];\r\n    }\r\n}\r\n"
    },
    "contracts/staking/StakingControllerLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport { CNFITreasury } from \"../treasury/CNFITreasury.sol\";\r\nimport { ICNFI } from \"../interfaces/ICNFI.sol\";\r\nimport { pCNFI } from \"../token/pCNFI.sol\";\r\nimport { sCNFI } from \"../token/sCNFI.sol\";\r\n\r\ncontract StakingControllerLib {\r\n    struct Isolate {\r\n      uint256 currentCycle;\r\n      CNFITreasury cnfiTreasury;\r\n      ICNFI cnfi;\r\n      sCNFI sCnfi;\r\n      pCNFI pCnfi;\r\n      uint256 nextCycleTime;\r\n      uint256 cycleInterval;\r\n      uint256 nextTimestamp;\r\n      uint256 inflateBy;\r\n      uint256 inflatepcnfiBy;\r\n      uint256 rewardInterval;\r\n      uint256 tiersLength;\r\n      uint256 baseUnstakePenalty;\r\n      uint256 commitmentViolationPenalty;\r\n      uint256 totalWeight;\r\n      uint256 lastTotalWeight;\r\n      uint256 cumulativeTotalWeight;\r\n      mapping(uint256 => StakingControllerLib.Cycle) cycles;\r\n      mapping(uint256 => StakingControllerLib.Tier) tiers;\r\n      mapping(address => uint256) lockCommitments;\r\n      mapping(address => uint256) bonusesAccrued;\r\n      mapping(address => uint256) dailyBonusesAccrued;\r\n      mapping(address => StakingControllerLib.UserWeightChanges) weightChanges;\r\n      mapping(address => StakingControllerLib.DailyUser) dailyUsers;\r\n      uint256[] inflateByChanged;\r\n      mapping(uint256 => StakingControllerLib.InflateByChanged) inflateByValues;\r\n      address pCnfiImplementation;\r\n      uint256 currentDay;\r\n    }\r\n    struct User {\r\n        uint256 currentWeight;\r\n        uint256 minimumWeight;\r\n        uint256 dailyWeight;\r\n        uint256 multiplier;\r\n        uint256 redeemable;\r\n        uint256 daysClaimed;\r\n        uint256 start;\r\n        bool seen;\r\n        uint256 currentTier;\r\n        uint256 cyclesHeld;\r\n    }\r\n    struct DailyUser {\r\n        uint256 multiplier;\r\n        uint256 cycleEnd;\r\n        uint256 cyclesHeld;\r\n        uint256 redeemable;\r\n        uint256 start;\r\n        uint256 weight;\r\n        uint256 claimed;\r\n        uint256 commitment;\r\n        uint256 lastDaySeen;\r\n        uint256 cumulativeTotalWeight;\r\n        uint256 cumulativeRewardWeight;\r\n        uint256 lastTotalWeight;\r\n        uint256 currentTier;\r\n    }\r\n    struct DetermineMultiplierLocals {\r\n        uint256 scnfiBalance;\r\n        uint256 minimum;\r\n        uint256 tierIndex;\r\n        Tier tier;\r\n        uint256 cyclesHeld;\r\n        uint256 multiplier;\r\n    }\r\n    struct DetermineRewardLocals {\r\n        uint256 lastDaySeen;\r\n        uint256 redeemable;\r\n        uint256 totalWeight;\r\n        uint256 multiplier;\r\n        uint256 weight;\r\n        uint256 rawWeight;\r\n        uint256 totalRawWeight;\r\n    }\r\n    struct ReturnStats {\r\n        uint256 lockCommitment;\r\n        uint256 totalStakedInProtocol;\r\n        uint256 cnfiReleasedPerDay;\r\n        uint256 staked;\r\n        uint256 currentCnfiBalance;\r\n        uint256 unstakePenalty;\r\n        uint256 redeemable;\r\n        uint256 bonuses;\r\n        uint256 apy;\r\n        uint256 commitmentViolationPenalty;\r\n        uint256 basePenalty;\r\n        uint256 totalWeight;\r\n        uint256 cycleChange;\r\n        uint256 totalCyclesSeen;\r\n    }\r\n    struct Cycle {\r\n        uint256 totalWeight;\r\n        uint256 totalRawWeight;\r\n        address pCnfiToken;\r\n        uint256 reserved;\r\n        uint256 day;\r\n        uint256 inflateBy;\r\n        mapping(address => User) users;\r\n        mapping(uint256 => uint256) cnfiRewards;\r\n        mapping(uint256 => uint256) pcnfiRewards;\r\n        bool canUnstake;\r\n    }\r\n    struct Tier {\r\n        uint256 multiplier;\r\n        uint256 minimum;\r\n        uint256 cycles;\r\n    }\r\n    struct EncodeableCycle {\r\n        uint256 totalWeight;\r\n        uint256 totalRawWeight;\r\n        address pCnfiToken;\r\n        uint256 reserved;\r\n        uint256 day;\r\n        bool canUnstake;\r\n        uint256 lastCycleSeen;\r\n        uint256 currentCycle;\r\n    }\r\n    struct UpdateLocals {\r\n        uint256 multiplier;\r\n        uint256 weight;\r\n        uint256 prevMul;\r\n        uint256 prevRes;\r\n        uint256 prevRawRes;\r\n        uint256 nextRes;\r\n        uint256 nextRawRes;\r\n    }\r\n    struct RecalculateLocals {\r\n        uint256 currentWeight;\r\n        uint256 previousMultiplier;\r\n        uint256 previousMinimumWeight;\r\n        uint256 previousTotalWeight;\r\n        uint256 totalInflated;\r\n        uint256 daysToRedeem;\r\n        uint256 previousRedeemable;\r\n        uint256 amt;\r\n        uint256 bonus;\r\n        uint256 minimumWeight;\r\n        uint256 multiplier;\r\n        uint256 currentTotalWeight;\r\n    }\r\n    struct InflateByChanged {\r\n        uint256 totalWeight;\r\n        uint256 previousAmount;\r\n    }\r\n    struct DetermineInflateLocals {\r\n        uint256 totalWeight;\r\n        uint256 lastDaySeen;\r\n        uint256 dayDifference;\r\n        InflateByChanged changed;\r\n        uint256 tempRedeemable;\r\n        uint256 redeemable;\r\n        uint256 daysToClaim;\r\n        uint256 lastDayInEpoch;\r\n        uint256 dayChanged;\r\n        uint256 tempBonus;\r\n        uint256 lastDayChanged;\r\n    }\r\n    struct UserWeightChanges {\r\n        mapping(uint256 => uint256) changes;\r\n        uint256 totalCyclesSeen;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "contracts/staking/ComputeCyclesHeldLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport {\r\n  SafeMathUpgradeable\r\n} from '@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol';\r\n\r\nlibrary ComputeCyclesHeldLib {\r\n  using SafeMathUpgradeable for *;\r\n\r\n  function _computeCyclesHeld(\r\n    uint256 cycleEnd,\r\n    uint256 interval,\r\n    uint256 _cyclesHeld,\r\n    uint256 currentTimestamp\r\n  ) internal pure returns (uint256 newCycleEnd, uint256 newCyclesHeld) {\r\n    if (cycleEnd == 0) cycleEnd = currentTimestamp.add(interval);\r\n    if (cycleEnd > currentTimestamp) return (cycleEnd, _cyclesHeld);\r\n    uint256 additionalCycles = currentTimestamp.sub(cycleEnd).div(interval);\r\n    newCyclesHeld = _cyclesHeld.add(1).add(additionalCycles);\r\n    newCycleEnd = cycleEnd.add(interval.mul(additionalCycles.add(1)));\r\n  }\r\n}\r\n"
    },
    "contracts/staking/UpdateRedeemableImplLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport {\r\n  SafeMathUpgradeable\r\n} from '@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol';\r\nimport { StakingControllerLib } from './StakingControllerLib.sol';\r\nimport {\r\n  MathUpgradeable as Math\r\n} from '@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol';\r\nimport { UpdateToLastImplLib } from './UpdateToLastImplLib.sol';\r\nimport { sCNFI } from '../token/sCNFI.sol';\r\nimport { ComputeCyclesHeldLib } from './ComputeCyclesHeldLib.sol';\r\nimport { BancorFormulaLib } from '../math/BancorFormulaLib.sol';\r\n\r\n\r\nlibrary UpdateRedeemableImplLib {\r\n  using SafeMathUpgradeable for *;\r\n  using BancorFormulaLib for *;\r\n\r\n  function _updateCumulativeRewards(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    address _user\r\n  ) internal {\r\n    StakingControllerLib.DailyUser storage user = isolate.dailyUsers[_user];\r\n    if (user.multiplier == 0) user.multiplier = uint256(1 ether);\r\n    if (isolate.currentDay > user.lastDaySeen) {\r\n      user.cumulativeRewardWeight = user.cumulativeRewardWeight.add(\r\n        isolate.currentDay.sub(user.lastDaySeen).mul(user.weight)\r\n      );\r\n    } else user.cumulativeRewardWeight = 0;\r\n  }\r\n\r\n  function _updateRedeemable(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    StakingControllerLib.DailyUser storage user,\r\n    uint256 multiplier\r\n  ) internal view returns (uint256 redeemable, uint256 bonuses) {\r\n    StakingControllerLib.DetermineInflateLocals memory locals;\r\n    locals.lastDayInEpoch = isolate.currentDay - 1;\r\n    locals.lastDayChanged = user.lastDaySeen;\r\n    if (locals.lastDayChanged < isolate.currentDay) {\r\n      locals.dayDifference = isolate.currentDay.sub(locals.lastDayChanged);\r\n      /*\r\n            locals.totalWeight = isolate.cumulativeTotalWeight.sub(\r\n                user.cumulativeTotalWeight\r\n            );\r\n            if (locals.totalWeight == 0) return (0, 0);\r\n*/\r\n\r\n      uint256 denominator =\r\n        Math.max(\r\n          Math.min(\r\n            isolate.cumulativeTotalWeight.sub(user.cumulativeTotalWeight),\r\n            Math.max(Math.max(isolate.totalWeight, isolate.lastTotalWeight), user.lastTotalWeight).mul(locals.dayDifference)\r\n          ),\r\n          uint256(1 ether)\r\n        );\r\n    \r\n      redeemable = locals\r\n        .dayDifference\r\n        .mul(isolate.inflateBy)\r\n        .mul(user.cumulativeRewardWeight)\r\n        .div(denominator);\r\n\r\n      if (multiplier > uint256(1 ether))\r\n        bonuses = redeemable.mul(multiplier.sub(uint256(1 ether))).div(\r\n          multiplier\r\n        );\r\n      else bonuses = 0;\r\n    }\r\n  }\r\n\r\n  function _determineMultiplier(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    bool penaltyChange,\r\n    address user,\r\n    uint256 currentBalance\r\n  ) internal returns (uint256 multiplier, uint256 amountToBurn) {\r\n    StakingControllerLib.DetermineMultiplierLocals memory locals;\r\n    StakingControllerLib.User storage currentUser =\r\n      isolate.cycles[isolate.currentCycle].users[user];\r\n    locals.minimum = uint256(~0);\r\n    locals.tierIndex = isolate.lockCommitments[user];\r\n    locals.tier = isolate.tiers[locals.tierIndex];\r\n    locals.cyclesHeld = 0;\r\n    locals.multiplier = locals.tierIndex == 0\r\n      ? 1 ether\r\n      : locals.tier.multiplier;\r\n    for (uint256 i = isolate.currentCycle; i > 0; i--) {\r\n      StakingControllerLib.Cycle storage cycle = isolate.cycles[i];\r\n      StakingControllerLib.User storage _user = cycle.users[user];\r\n      locals.minimum = Math.min(locals.minimum, _user.minimumWeight);\r\n      currentUser.cyclesHeld = locals.cyclesHeld;\r\n      currentUser.currentTier = locals.tierIndex;\r\n      if (locals.minimum < locals.tier.minimum) {\r\n        if (\r\n          isolate.lockCommitments[user] == locals.tierIndex && penaltyChange\r\n        ) {\r\n          uint256 bonus = isolate.bonusesAccrued[user];\r\n          amountToBurn = Math.min(bonus, currentBalance);\r\n\r\n          if (amountToBurn > 0) {\r\n            isolate.bonusesAccrued[user] = 0;\r\n            isolate.lockCommitments[user] = 0;\r\n            currentUser.currentTier = 0;\r\n            currentUser.cyclesHeld = 0;\r\n          }\r\n        }\r\n        return (locals.multiplier, amountToBurn);\r\n      }\r\n      locals.cyclesHeld++;\r\n      if (locals.tierIndex == 0) {\r\n        locals.tierIndex++;\r\n        if (locals.tierIndex > isolate.tiersLength)\r\n          return (locals.multiplier, amountToBurn);\r\n        locals.tier = isolate.tiers[locals.tierIndex];\r\n      }\r\n      if (locals.cyclesHeld == locals.tier.cycles) {\r\n        locals.multiplier = locals.tier.multiplier;\r\n        locals.tierIndex++;\r\n\r\n        isolate.lockCommitments[user] = 0;\r\n        isolate.bonusesAccrued[user] = 0;\r\n        if (locals.tierIndex > isolate.tiersLength)\r\n          return (locals.multiplier, amountToBurn);\r\n        locals.tier = isolate.tiers[locals.tierIndex];\r\n      }\r\n    }\r\n    return (locals.multiplier, amountToBurn);\r\n  }\r\n\r\n  function _updateDailyStatsToLast(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    address sender,\r\n    uint256 weight,\r\n    bool penalize,\r\n    bool init\r\n  ) internal returns (uint256 redeemable, uint256 bonuses) {\r\n    StakingControllerLib.DailyUser storage user = isolate.dailyUsers[sender];\r\n    StakingControllerLib.UserWeightChanges storage weightChange =\r\n      isolate.weightChanges[sender];\r\n    if (user.start == 0) init = true;\r\n    {\r\n      uint256 cycleChange = user.cyclesHeld;\r\n      (user.cycleEnd, user.cyclesHeld) = ComputeCyclesHeldLib\r\n        ._computeCyclesHeld(\r\n        user.cycleEnd,\r\n        isolate.cycleInterval,\r\n        user.cyclesHeld,\r\n        block.timestamp\r\n      );\r\n      if (user.cyclesHeld > 0 && user.cyclesHeld > cycleChange) {\r\n        uint256 baseWeight = isolate.sCnfi.balanceOf(sender);\r\n        for (uint256 i = user.cyclesHeld; i > cycleChange; i--) {\r\n          weightChange.changes[i] = baseWeight;\r\n        }\r\n        weightChange.totalCyclesSeen = user.cyclesHeld;\r\n      }\r\n    }\r\n    if (penalize || init) {\r\n      weightChange.changes[user.cyclesHeld] = weight;\r\n      user.start = block.timestamp;\r\n    }\r\n    uint256 multiplier = _determineDailyMultiplier(isolate, sender);\r\n    \r\n    if (init) user.multiplier = multiplier;\r\n    if (user.lastDaySeen < isolate.currentDay) {\r\n      (redeemable, bonuses) = _updateRedeemable(isolate, user, multiplier);\r\n      user.cumulativeTotalWeight = isolate.cumulativeTotalWeight;\r\n      user.cumulativeRewardWeight = 0;\r\n      isolate.dailyBonusesAccrued[sender] = isolate.dailyBonusesAccrued[sender]\r\n        .add(bonuses);\r\n      user.claimed = user.claimed.add(redeemable);\r\n      user.redeemable = user.redeemable.add(redeemable);\r\n      user.lastDaySeen = isolate.currentDay;\r\n    }\r\n    /*\r\n        {\r\n            if (!init && user.multiplier != multiplier && user.multiplier > 0) {\r\n                uint256 previousUserWeight =\r\n                    user.weight;\r\n                uint256 newUserWeight =\r\n                    weight.mul(multiplier).div(uint256(1 ether));\r\n\r\n                if (isolate.totalWeight == previousUserWeight)\r\n                    isolate.totalWeight = newUserWeight;\r\n                else\r\n                    isolate.totalWeight = isolate\r\n                        .totalWeight\r\n                        .add(newUserWeight)\r\n                        .sub(previousUserWeight);\r\n            }\r\n        }\r\n\t*/\r\n    user.multiplier = multiplier;\r\n    if (penalize) {\r\n      _deductRewards(isolate, sender, weight);\r\n      user.cycleEnd = block.timestamp + isolate.cycleInterval;\r\n      user.cyclesHeld = 0;\r\n      if (isolate.tiersLength > 0) {\r\n        uint256 min = isolate.tiers[1].minimum;\r\n        if (min > weight) weightChange.totalCyclesSeen = 0;\r\n        else {\r\n          weightChange.changes[weightChange.totalCyclesSeen] = weight;\r\n        }\r\n      } else {\r\n        weightChange.totalCyclesSeen = 0;\r\n      }\r\n \r\n    }\r\n  }\r\n\r\n  function _recalculateDailyWeights(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    address sender,\r\n    uint256 weight,\r\n    bool penalize\r\n  ) internal {\r\n    StakingControllerLib.DailyUser storage user = isolate.dailyUsers[sender];\r\n    uint256 previousMultiplier = user.multiplier;\r\n    if (previousMultiplier == 0) {\r\n      previousMultiplier = 1 ether;\r\n      user.multiplier = previousMultiplier;\r\n      user.weight = isolate.sCnfi.balanceOf(sender);\r\n    }\r\n    uint256 prevWeight = user.weight;\r\n    _updateDailyStatsToLast(isolate, sender, weight, penalize, false);\r\n    user.weight = weight = weight.mul(user.multiplier).div(1 ether);\r\n    isolate.lastTotalWeight = isolate.totalWeight;\r\n    isolate.totalWeight = isolate.totalWeight.add(weight).sub(prevWeight);\r\n    \r\n\r\n    user.lastTotalWeight = isolate.totalWeight;\r\n  }\r\n\r\n  function _deductRewards(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    address sender,\r\n    uint256 weight\r\n  ) internal {\r\n    StakingControllerLib.DailyUser storage user = isolate.dailyUsers[sender];\r\n    StakingControllerLib.Tier memory tier;\r\n    if (user.commitment > 0) {\r\n      tier = isolate.tiers[user.commitment];\r\n      if (weight < tier.minimum && user.cyclesHeld < tier.cycles) {\r\n        user.commitment = 0;\r\n        (uint256 redeemable, uint256 toBurn) =\r\n          _computeNewRedeemablePrincipalSplit(isolate, sender);\r\n        isolate.dailyBonusesAccrued[sender] = 0;\r\n        user.redeemable = redeemable;\r\n        isolate.sCnfi.burn(sender, toBurn);\r\n        user.multiplier = uint256(1 ether);\r\n      }\r\n    }\r\n  }\r\n\r\n  function _computeNewRedeemablePrincipalSplit(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    address user\r\n  ) internal view returns (uint256 newRedeemable, uint256 toBurn) {\r\n    uint256 total =\r\n      isolate.dailyBonusesAccrued[user]\r\n        .mul(isolate.commitmentViolationPenalty)\r\n        .div(uint256(1 ether));\r\n    StakingControllerLib.DailyUser storage dailyUser = isolate.dailyUsers[user];\r\n    uint256 _redeemable = dailyUser.redeemable;\r\n\r\n    newRedeemable =\r\n      dailyUser.redeemable -\r\n      Math.min(dailyUser.redeemable, total);\r\n    if (newRedeemable == 0) {\r\n      toBurn = total - _redeemable;\r\n    }\r\n  }\r\n\r\n  function _recalculateWeights(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    address sender,\r\n    uint256 oldBalance,\r\n    uint256 newBalance,\r\n    bool penalty\r\n  ) internal {\r\n    StakingControllerLib.RecalculateLocals memory locals;\r\n    UpdateToLastImplLib._updateToLast(isolate, sender);\r\n    StakingControllerLib.Cycle storage cycle =\r\n      isolate.cycles[isolate.currentCycle];\r\n    StakingControllerLib.User storage user = cycle.users[sender];\r\n    //StakingControllerLib.User storage dailyUser = cycle.users[sender];\r\n    user.start = block.timestamp;\r\n\r\n    locals.currentWeight = user.currentWeight;\r\n    if (oldBalance != newBalance) {\r\n      if (locals.currentWeight == oldBalance) user.currentWeight = newBalance;\r\n      else\r\n        user.currentWeight = locals.currentWeight.add(newBalance).sub(\r\n          oldBalance\r\n        );\r\n    }\r\n    // _recalculateDailyWeights(isolate, sender, newBalance.mul(dailyUser.multiplier).div(uint256(1 ether)), penalty);\r\n    locals.previousMultiplier = user.multiplier;\r\n    locals.previousMinimumWeight = user.minimumWeight;\r\n    locals.previousTotalWeight = cycle.totalWeight;\r\n    if (\r\n      user.daysClaimed - cycle.day - 1 > 0 && locals.previousMinimumWeight > 0\r\n    ) {\r\n      locals.totalInflated;\r\n      locals.daysToRedeem;\r\n      if (cycle.day - 1 > user.daysClaimed)\r\n        locals.daysToRedeem = uint256(cycle.day - 1).sub(user.daysClaimed);\r\n      locals.totalInflated = isolate.inflateBy.mul(locals.daysToRedeem);\r\n      locals.previousRedeemable = user.redeemable;\r\n\r\n      if (locals.totalInflated > 0) {\r\n        locals.amt = locals\r\n          .totalInflated\r\n          .mul(locals.previousMinimumWeight)\r\n          .mul(locals.previousMultiplier)\r\n          .div(1 ether)\r\n          .div(locals.previousTotalWeight);\r\n        user.redeemable = locals.previousRedeemable.add(locals.amt);\r\n        if (locals.previousMultiplier > 1 ether) {\r\n          locals.bonus = locals\r\n            .amt\r\n            .mul(locals.previousMultiplier.sub(1 ether))\r\n            .div(locals.previousMultiplier);\r\n          isolate.bonusesAccrued[sender] = isolate.bonusesAccrued[sender].add(\r\n            locals.bonus\r\n          );\r\n        }\r\n        user.daysClaimed = cycle.day - 1;\r\n      }\r\n    }\r\n    locals.minimumWeight = Math.min(user.minimumWeight, locals.currentWeight);\r\n    (locals.multiplier, ) = _determineMultiplier(\r\n      isolate,\r\n      penalty,\r\n      sender,\r\n      newBalance\r\n    );\r\n    user.minimumWeight = locals.minimumWeight;\r\n    locals.currentTotalWeight = cycle\r\n      .totalWeight\r\n      .add(locals.minimumWeight.mul(locals.multiplier).div(uint256(1 ether)))\r\n      .sub(\r\n      locals.previousMinimumWeight.mul(locals.previousMultiplier).div(\r\n        uint256(1 ether)\r\n      )\r\n    );\r\n\r\n    cycle.totalWeight = locals.currentTotalWeight;\r\n    cycle.totalRawWeight = cycle\r\n      .totalRawWeight\r\n      .add(user.currentWeight.mul(locals.multiplier).div(1 ether))\r\n      .sub(locals.currentWeight.mul(locals.previousMultiplier).div(1 ether));\r\n\r\n    user.multiplier = locals.multiplier;\r\n  }\r\n\r\n  function _determineDailyMultiplier(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    address sender\r\n  ) internal returns (uint256 multiplier) {\r\n    StakingControllerLib.DailyUser storage user = isolate.dailyUsers[sender];\r\n    StakingControllerLib.UserWeightChanges storage weightChange =\r\n      isolate.weightChanges[sender];\r\n    StakingControllerLib.DetermineMultiplierLocals memory locals;\r\n    locals.tierIndex = Math.max(user.commitment, user.currentTier);\r\n    locals.tier = isolate.tiers[locals.tierIndex];\r\n    locals.multiplier = locals.tierIndex == 0\r\n      ? 1 ether\r\n      : locals.tier.multiplier;\r\n    multiplier = locals.multiplier;\r\n    user.currentTier = 0;\r\n    locals.minimum = uint256(~1);\r\n    for (uint256 i = weightChange.totalCyclesSeen; i > 0; i--) {\r\n      locals.minimum = Math.min(locals.minimum, weightChange.changes[i]);\r\n      if (locals.minimum < locals.tier.minimum) {\r\n        \r\n        if (locals.tierIndex > 0 && locals.tierIndex > user.commitment)\r\n          user.currentTier = --locals.tierIndex;\r\n        locals.tier = isolate.tiers[locals.tierIndex];\r\n        locals.multiplier = locals.tier.multiplier;\r\n        return locals.multiplier;\r\n      }\r\n      user.currentTier = locals.tierIndex;\r\n      locals.cyclesHeld++;\r\n      if (locals.cyclesHeld >= locals.tier.cycles) {\r\n        if (user.commitment == locals.tierIndex) {\r\n          user.commitment = 0;\r\n        }\r\n        locals.tierIndex++;\r\n\r\n        if (locals.tierIndex > isolate.tiersLength - 1) {\r\n          return isolate.tiers[--locals.tierIndex].multiplier;\r\n        }\r\n        locals.tier = isolate.tiers[locals.tierIndex];\r\n\r\n        locals.multiplier = locals.tier.multiplier;\r\n      }\r\n    }\r\n    if(user.commitment == 0) {\r\n      locals.tier = isolate.tiers[user.currentTier];\r\n      multiplier = locals.tier.multiplier;\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/staking/GetDisplayTierImplLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport { StakingControllerLib } from \"./StakingControllerLib.sol\";\r\n\r\nlibrary GetDisplayTierImplLib {\r\n  function _getDisplayTier(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    uint256 tier,\r\n    uint256 newBalance\r\n  ) internal view returns (uint256) {\r\n    for (; tier < isolate.tiersLength; tier++) {\r\n      if (isolate.tiers[tier].minimum > newBalance) {\r\n        tier--;\r\n        break;\r\n      }\r\n    }\r\n    if(tier >= isolate.tiersLength) tier--;\r\n    return tier;\r\n  }\r\n}\r\n"
    },
    "contracts/staking/CalculateRewardsImplLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport {StakingControllerLib} from \"./StakingControllerLib.sol\";\r\nimport {\r\n    SafeMathUpgradeable\r\n} from \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\r\nimport {\r\n    MathUpgradeable as Math\r\n} from \"@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol\";\r\nimport {UpdateRedeemableImplLib} from \"./UpdateRedeemableImplLib.sol\";\r\n\r\nlibrary CalculateRewardsImplLib {\r\n    using SafeMathUpgradeable for *;\r\n    struct CalculateRewardsLocals {\r\n        uint256 weight;\r\n        uint256 totalWeight;\r\n        uint256 daysToRedeem;\r\n        uint256 amountRedeemed;\r\n    }\r\n\r\n    function _calculateRewards(\r\n        StakingControllerLib.Isolate storage isolate,\r\n        address _user,\r\n        uint256 amt,\r\n        bool isView\r\n    ) internal returns (uint256 amountToRedeem, uint256 bonuses) {\r\n        StakingControllerLib.DailyUser storage user = isolate.dailyUsers[_user];\r\n        (amountToRedeem, bonuses) = _computeRewards(isolate, _user);\r\n\r\n        require(\r\n            isView || amountToRedeem >= amt,\r\n            \"cannot redeem more than whats available\"\r\n        );\r\n        uint256 _redeemable = user.redeemable;\r\n        if (amt == 0) amt = _redeemable;\r\n        user.redeemable = _redeemable.sub(amt);\r\n        return (amt, bonuses);\r\n    }\r\n\r\n    function _computeRewards(\r\n        StakingControllerLib.Isolate storage isolate,\r\n        address _user\r\n    ) internal view returns (uint256 amountToRedeem, uint256 bonuses) {\r\n        amountToRedeem = isolate.dailyUsers[_user].redeemable;\r\n        bonuses = isolate.dailyBonusesAccrued[_user];\r\n    }\r\n}\r\n"
    },
    "contracts/util/ViewExecutor.sol": {
      "content": "pragma experimental ABIEncoderV2;\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport {RevertCaptureLib} from \"./RevertCaptureLib.sol\";\r\n\r\ncontract ViewExecutor {\r\n    function encodeExecuteQuery(address viewLogic, bytes memory payload)\r\n        internal\r\n        pure\r\n        returns (bytes memory retval)\r\n    {\r\n        retval = abi.encodeWithSignature(\r\n            \"_executeQuery(address,bytes)\",\r\n            viewLogic,\r\n            payload\r\n        );\r\n    }\r\n\r\n    function query(address viewLogic, bytes memory payload)\r\n        public\r\n        returns (bytes memory)\r\n    {\r\n        (bool success, bytes memory response) =\r\n            address(this).call(encodeExecuteQuery(viewLogic, payload));\r\n        if (success) revert(RevertCaptureLib.decodeError(response));\r\n        return response;\r\n    }\r\n\r\n    function _bubbleReturnData(bytes memory result)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        assembly {\r\n            return(add(result, 0x20), mload(result))\r\n        }\r\n    }\r\n\r\n    function _bubbleRevertData(bytes memory result)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        assembly {\r\n            revert(add(result, 0x20), mload(result))\r\n        }\r\n    }\r\n\r\n    function _executeQuery(address delegateTo, bytes memory callData)\r\n        public\r\n        returns (bytes memory)\r\n    {\r\n        require(\r\n            msg.sender == address(this),\r\n            \"unauthorized view layer delegation\"\r\n        );\r\n        (bool success, bytes memory retval) = delegateTo.delegatecall(callData);\r\n\r\n        if (success) _bubbleRevertData(retval);\r\n        return _bubbleReturnData(retval);\r\n    }\r\n}\r\n"
    },
    "contracts/treasury/CNFITreasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport {\r\n    OwnableUpgradeable\r\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport {\r\n    IERC20Upgradeable\r\n} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\r\n\r\ncontract CNFITreasury is OwnableUpgradeable {\r\n    address relayer;\r\n    modifier onlyRelayer {\r\n        require(msg.sender == owner() || msg.sender == relayer, \"unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function initialize(address _relayer) public {\r\n        __Ownable_init_unchained();\r\n        relayer = _relayer;\r\n    }\r\n\r\n    function transferToken(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    ) public onlyRelayer returns (bool) {\r\n        IERC20Upgradeable(token).transfer(to, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/ICNFI.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface ICNFI is IERC20 {\r\n  function mint(address user, uint256 amount) external;\r\n}\r\n"
    },
    "contracts/token/pCNFI.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport {\r\n  ERC20Upgradeable\r\n} from '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\r\nimport { StringUtils } from '../util/Strings.sol';\r\nimport {\r\n  OwnableUpgradeable\r\n} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\r\nimport { pCNFILib } from './lib/pCNFILib.sol';\r\n\r\ncontract pCNFI is ERC20Upgradeable, OwnableUpgradeable {\r\n  using StringUtils for *;\r\n\r\n  function initialize(uint256 cycle) public initializer {\r\n    __ERC20_init_unchained(pCNFILib.toName(cycle), pCNFILib.toSymbol(cycle));\r\n    __Ownable_init_unchained();\r\n  }\r\n\r\n  function mint(address target, uint256 amount) public onlyOwner {\r\n    _mint(target, amount);\r\n  }\r\n\r\n  function burn(address target, uint256 amount) public onlyOwner {\r\n    _burn(target, amount);\r\n  }\r\n}\r\n"
    },
    "contracts/token/sCNFI.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\r\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\n\r\ncontract sCNFI is ERC20Upgradeable, OwnableUpgradeable {\r\n  function initialize() public initializer {\r\n    __ERC20_init_unchained(\"Connect Financial Staking\", \"sCNFI\");\r\n    __Ownable_init_unchained();\r\n  }\r\n\r\n  function mint(address target, uint256 amount) public onlyOwner {\r\n    _mint(target, amount);\r\n  }\r\n\r\n  function burn(address target, uint256 amount) public onlyOwner {\r\n    _burn(target, amount);\r\n  }\r\n\r\n  function transfer(address target, uint256 amount)\r\n    public\r\n    override\r\n    onlyOwner\r\n    returns (bool)\r\n  {\r\n    return super.transfer(target, amount);\r\n  }\r\n\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) public override onlyOwner returns (bool) {\r\n    return super.transferFrom(from, to, amount);\r\n  }\r\n}\r\n"
    },
    "contracts/util/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/*\r\n * @title String & slice utility library for Solidity contracts.\r\n * @author Nick Johnson <arachnid@notdot.net>\r\n *\r\n * @dev Functionality in this library is largely implemented using an\r\n *      abstraction called a 'slice'. A slice represents a part of a string -\r\n *      anything from the entire string to a single character, or even no\r\n *      characters at all (a 0-length slice). Since a slice only has to specify\r\n *      an offset and a length, copying and manipulating slices is a lot less\r\n *      expensive than copying and manipulating the strings they reference.\r\n *\r\n *      To further reduce gas costs, most functions on slice that need to return\r\n *      a slice modify the original one instead of allocating a new one; for\r\n *      instance, `s.split(\".\")` will return the text up to the first '.',\r\n *      modifying s to only contain the remainder of the string after the '.'.\r\n *      In situations where you do not want to modify the original slice, you\r\n *      can make a copy first with `.copy()`, for example:\r\n *      `s.copy().split(\".\")`. Try and avoid using this idiom in loops; since\r\n *      Solidity has no memory management, it will result in allocating many\r\n *      short-lived slices that are later discarded.\r\n *\r\n *      Functions that return two slices come in two versions: a non-allocating\r\n *      version that takes the second slice as an argument, modifying it in\r\n *      place, and an allocating version that allocates and returns the second\r\n *      slice; see `nextRune` for example.\r\n *\r\n *      Functions that have to copy string data will return strings rather than\r\n *      slices; these can be cast back to slices for further processing if\r\n *      required.\r\n *\r\n *      For convenience, some functions are provided with non-modifying\r\n *      variants that create a new slice and return both; for instance,\r\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\r\n *      corresponding to the left and right parts of the string.\r\n */\r\n\r\npragma solidity ^0.6.0;\r\n\r\nlibrary StringUtils {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire string.\r\n     * @param self The string to make a slice from.\r\n     * @return A newly allocated slice containing the entire string.\r\n     */\r\n    function toSlice(string memory self) internal pure returns (slice memory) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length of a null-terminated bytes32 string.\r\n     * @param self The value to find the length of.\r\n     * @return The length of the string, from 0 to 32.\r\n     */\r\n    function len(bytes32 self) internal pure returns (uint) {\r\n        uint ret;\r\n        if (self == 0)\r\n            return 0;\r\n        if (self & bytes32(uint256(0xffffffffffffffffffffffffffffffff)) == 0) {\r\n            ret += 16;\r\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\r\n        }\r\n        if (self & bytes32(uint256(0xffffffffffffffff)) == 0) {\r\n            ret += 8;\r\n            self = bytes32(uint(self) / 0x10000000000000000);\r\n        }\r\n        if (self & bytes32(uint256(0xffffffff)) == 0) {\r\n            ret += 4;\r\n            self = bytes32(uint(self) / 0x100000000);\r\n        }\r\n        if (self & bytes32(uint256(0xffff)) == 0) {\r\n            ret += 2;\r\n            self = bytes32(uint(self) / 0x10000);\r\n        }\r\n        if (self & bytes32(uint256(0xff)) == 0) {\r\n            ret += 1;\r\n        }\r\n        return 32 - ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\r\n     *      null-terminated utf-8 string.\r\n     * @param self The bytes32 value to convert to a slice.\r\n     * @return A new slice containing the value of the input argument up to the\r\n     *         first null.\r\n     */\r\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\r\n        // Allocate space for `self` in memory, copy it there, and point ret at it\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(0x40, add(ptr, 0x20))\r\n            mstore(ptr, self)\r\n            mstore(add(ret, 0x20), ptr)\r\n        }\r\n        ret._len = len(self);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a new slice containing the same data as the current slice.\r\n     * @param self The slice to copy.\r\n     * @return A new slice containing the same data as `self`.\r\n     */\r\n    function copy(slice memory self) internal pure returns (slice memory) {\r\n        return slice(self._len, self._ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Copies a slice to a new string.\r\n     * @param self The slice to copy.\r\n     * @return A newly allocated string containing the slice's text.\r\n     */\r\n    function toString(slice memory self) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        memcpy(retptr, self._ptr, self._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length in runes of the slice. Note that this operation\r\n     *      takes time proportional to the length of the slice; avoid using it\r\n     *      in loops, and call `slice.empty()` if you only need to know whether\r\n     *      the slice is empty or not.\r\n     * @param self The slice to operate on.\r\n     * @return The length of the slice in runes.\r\n     */\r\n    function len(slice memory self) internal pure returns (uint l) {\r\n        // Starting at ptr-31 means the LSB will be the byte we care about\r\n        uint ptr = self._ptr - 31;\r\n        uint end = ptr + self._len;\r\n        for (l = 0; ptr < end; l++) {\r\n            uint8 b;\r\n            assembly { b := and(mload(ptr), 0xFF) }\r\n            if (b < 0x80) {\r\n                ptr += 1;\r\n            } else if(b < 0xE0) {\r\n                ptr += 2;\r\n            } else if(b < 0xF0) {\r\n                ptr += 3;\r\n            } else if(b < 0xF8) {\r\n                ptr += 4;\r\n            } else if(b < 0xFC) {\r\n                ptr += 5;\r\n            } else {\r\n                ptr += 6;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice is empty (has a length of 0).\r\n     * @param self The slice to operate on.\r\n     * @return True if the slice is empty, False otherwise.\r\n     */\r\n    function empty(slice memory self) internal pure returns (bool) {\r\n        return self._len == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a positive number if `other` comes lexicographically after\r\n     *      `self`, a negative number if it comes before, or zero if the\r\n     *      contents of the two slices are equal. Comparison is done per-rune,\r\n     *      on unicode codepoints.\r\n     * @param self The first slice to compare.\r\n     * @param other The second slice to compare.\r\n     * @return The result of the comparison.\r\n     */\r\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\r\n        uint shortest = self._len;\r\n        if (other._len < self._len)\r\n            shortest = other._len;\r\n\r\n        uint selfptr = self._ptr;\r\n        uint otherptr = other._ptr;\r\n        for (uint idx = 0; idx < shortest; idx += 32) {\r\n            uint a;\r\n            uint b;\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n            if (a != b) {\r\n                // Mask out irrelevant bytes and check again\r\n                uint256 mask = uint256(-1); // 0xffff...\r\n                if(shortest < 32) {\r\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\n                }\r\n                uint256 diff = (a & mask) - (b & mask);\r\n                if (diff != 0)\r\n                    return int(diff);\r\n            }\r\n            selfptr += 32;\r\n            otherptr += 32;\r\n        }\r\n        return int(self._len) - int(other._len);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the two slices contain the same text.\r\n     * @param self The first slice to compare.\r\n     * @param self The second slice to compare.\r\n     * @return True if the slices are equal, false otherwise.\r\n     */\r\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\r\n        return compare(self, other) == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\r\n     *      slice to point to the next rune and returning `self`.\r\n     * @param self The slice to operate on.\r\n     * @param rune The slice that will contain the first rune.\r\n     * @return `rune`.\r\n     */\r\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\r\n        rune._ptr = self._ptr;\r\n\r\n        if (self._len == 0) {\r\n            rune._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        uint l;\r\n        uint b;\r\n        // Load the first byte of the rune into the LSBs of b\r\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\r\n        if (b < 0x80) {\r\n            l = 1;\r\n        } else if(b < 0xE0) {\r\n            l = 2;\r\n        } else if(b < 0xF0) {\r\n            l = 3;\r\n        } else {\r\n            l = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (l > self._len) {\r\n            rune._len = self._len;\r\n            self._ptr += self._len;\r\n            self._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        self._ptr += l;\r\n        self._len -= l;\r\n        rune._len = l;\r\n        return rune;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the first rune in the slice, advancing the slice to point\r\n     *      to the next rune.\r\n     * @param self The slice to operate on.\r\n     * @return A slice containing only the first rune from `self`.\r\n     */\r\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\r\n        nextRune(self, ret);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the number of the first codepoint in the slice.\r\n     * @param self The slice to operate on.\r\n     * @return The number of the first codepoint in the slice.\r\n     */\r\n    function ord(slice memory self) internal pure returns (uint ret) {\r\n        if (self._len == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint word;\r\n        uint length;\r\n        uint divisor = 2 ** 248;\r\n\r\n        // Load the rune into the MSBs of b\r\n        assembly { word:= mload(mload(add(self, 32))) }\r\n        uint b = word / divisor;\r\n        if (b < 0x80) {\r\n            ret = b;\r\n            length = 1;\r\n        } else if(b < 0xE0) {\r\n            ret = b & 0x1F;\r\n            length = 2;\r\n        } else if(b < 0xF0) {\r\n            ret = b & 0x0F;\r\n            length = 3;\r\n        } else {\r\n            ret = b & 0x07;\r\n            length = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (length > self._len) {\r\n            return 0;\r\n        }\r\n\r\n        for (uint i = 1; i < length; i++) {\r\n            divisor = divisor / 256;\r\n            b = (word / divisor) & 0xFF;\r\n            if (b & 0xC0 != 0x80) {\r\n                // Invalid UTF-8 sequence\r\n                return 0;\r\n            }\r\n            ret = (ret * 64) | (b & 0x3F);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the keccak-256 hash of the slice.\r\n     * @param self The slice to hash.\r\n     * @return The hash of the slice.\r\n     */\r\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\r\n        assembly {\r\n            ret := keccak256(mload(add(self, 32)), mload(self))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if `self` starts with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        if (self._ptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let selfptr := mload(add(self, 0x20))\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` starts with `needle`, `needle` is removed from the\r\n     *      beginning of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        bool equal = true;\r\n        if (self._ptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let selfptr := mload(add(self, 0x20))\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n            self._ptr += needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice ends with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        uint selfptr = self._ptr + self._len - needle._len;\r\n\r\n        if (selfptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` ends with `needle`, `needle` is removed from the\r\n     *      end of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        uint selfptr = self._ptr + self._len - needle._len;\r\n        bool equal = true;\r\n        if (selfptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    // Returns the memory address of the first byte of the first occurrence of\r\n    // `needle` in `self`, or the first byte after `self` if not found.\r\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr = selfptr;\r\n        uint idx;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                uint end = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr >= end)\r\n                        return selfptr + selflen;\r\n                    ptr++;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n\r\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr;\r\n                    ptr += 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr + selflen;\r\n    }\r\n\r\n    // Returns the memory address of the first byte after the last occurrence of\r\n    // `needle` in `self`, or the address of `self` if not found.\r\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                ptr = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr <= selfptr)\r\n                        return selfptr;\r\n                    ptr--;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr + needlelen;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n                ptr = selfptr + (selflen - needlelen);\r\n                while (ptr >= selfptr) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr + needlelen;\r\n                    ptr -= 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain everything from the first occurrence of\r\n     *      `needle` to the end of the slice. `self` is set to the empty slice\r\n     *      if `needle` is not found.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len -= ptr - self._ptr;\r\n        self._ptr = ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain the part of the string from the start of\r\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\r\n     *      is not found, `self` is set to the empty slice.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len = ptr - self._ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and `token` to everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = self._ptr;\r\n        token._len = ptr - self._ptr;\r\n        if (ptr == self._ptr + self._len) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n            self._ptr = ptr + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and returning everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` up to the first occurrence of `delim`.\r\n     */\r\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\r\n        split(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and `token` to everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = ptr;\r\n        token._len = self._len - (ptr - self._ptr);\r\n        if (ptr == self._ptr) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and returning everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` after the last occurrence of `delim`.\r\n     */\r\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\r\n        rsplit(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The number of occurrences of `needle` found in `self`.\r\n     */\r\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\r\n        while (ptr <= self._ptr + self._len) {\r\n            cnt++;\r\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns True if `self` contains `needle`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return True if `needle` is found in `self`, false otherwise.\r\n     */\r\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a newly allocated string containing the concatenation of\r\n     *      `self` and `other`.\r\n     * @param self The first slice to concatenate.\r\n     * @param other The second slice to concatenate.\r\n     * @return The concatenation of the two strings.\r\n     */\r\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len + other._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n        memcpy(retptr, self._ptr, self._len);\r\n        memcpy(retptr + self._len, other._ptr, other._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\r\n     *      newly allocated string.\r\n     * @param self The delimiter to use.\r\n     * @param parts A list of slices to join.\r\n     * @return A newly allocated string containing all the slices in `parts`,\r\n     *         joined with `self`.\r\n     */\r\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\r\n        if (parts.length == 0)\r\n            return \"\";\r\n\r\n        uint length = self._len * (parts.length - 1);\r\n        for(uint i = 0; i < parts.length; i++)\r\n            length += parts[i]._len;\r\n\r\n        string memory ret = new string(length);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        for(uint i = 0; i < parts.length; i++) {\r\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\r\n            retptr += parts[i]._len;\r\n            if (i < parts.length - 1) {\r\n                memcpy(retptr, self._ptr, self._len);\r\n                retptr += self._len;\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n    // convert uint to string\r\n    function toString(uint256 _i) internal pure returns (string memory) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 j = _i;\r\n        uint256 length;\r\n        while (j != 0) {\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint256 k = length - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n}\r\n"
    },
    "contracts/token/lib/pCNFILib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport { StringLib } from '../../util/StringLib.sol';\r\nimport { IStakingController } from '../../interfaces/IStakingController.sol';\r\n\r\nlibrary pCNFILib {\r\n  using StringLib for *;\r\n\r\n  function toSymbol(uint256 cycle) internal pure returns (string memory) {\r\n    return abi.encodePacked('pCNFI', cycle.toString()).toString();\r\n  }\r\n\r\n  function toName(uint256 cycle) internal pure returns (string memory) {\r\n    return abi.encodePacked('pCNFI Cycle ', cycle.toString()).toString();\r\n  }\r\n}\r\n"
    },
    "contracts/util/StringLib.sol": {
      "content": "pragma experimental ABIEncoderV2;\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nlibrary StringLib {\r\n  /// @notice Convert a uint value to its decimal string representation\r\n  // solium-disable-next-line security/no-assign-params\r\n  function toString(uint256 _i) internal pure returns (string memory) {\r\n    if (_i == 0) {\r\n      return '0';\r\n    }\r\n    uint256 j = _i;\r\n    uint256 len;\r\n    while (j != 0) {\r\n      len++;\r\n      j /= 10;\r\n    }\r\n    bytes memory bstr = new bytes(len);\r\n    uint256 k = len - 1;\r\n    while (_i != 0) {\r\n      bstr[k--] = bytes1(uint8(48 + (_i % 10)));\r\n      _i /= 10;\r\n    }\r\n    return string(bstr);\r\n  }\r\n\r\n  /// @notice Convert a bytes32 value to its hex string representation\r\n  function toString(bytes32 _value) internal pure returns (string memory) {\r\n    bytes memory alphabet = '0123456789abcdef';\r\n\r\n    bytes memory str = new bytes(32 * 2 + 2);\r\n    str[0] = '0';\r\n    str[1] = 'x';\r\n    for (uint256 i = 0; i < 32; i++) {\r\n      str[2 + i * 2] = alphabet[uint256(uint8(_value[i] >> 4))];\r\n      str[3 + i * 2] = alphabet[uint256(uint8(_value[i] & 0x0f))];\r\n    }\r\n    return string(str);\r\n  }\r\n\r\n  /// @notice Convert an address to its hex string representation\r\n  function toString(address _addr) internal pure returns (string memory) {\r\n    bytes32 value = bytes32(uint256(_addr));\r\n    bytes memory alphabet = '0123456789abcdef';\r\n\r\n    bytes memory str = new bytes(20 * 2 + 2);\r\n    str[0] = '0';\r\n    str[1] = 'x';\r\n    for (uint256 i = 0; i < 20; i++) {\r\n      str[2 + i * 2] = alphabet[uint256(uint8(value[i + 12] >> 4))];\r\n      str[3 + i * 2] = alphabet[uint256(uint8(value[i + 12] & 0x0f))];\r\n    }\r\n    return string(str);\r\n  }\r\n\r\n  function toString(bytes memory input) internal pure returns (string memory) {\r\n    return string(input);\r\n  }\r\n}\r\n"
    },
    "contracts/util/RevertCaptureLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport {SliceLib} from \"./SliceLib.sol\";\r\n\r\nlibrary RevertCaptureLib {\r\n    using SliceLib for *;\r\n    uint32 constant REVERT_WITH_REASON_MAGIC = 0x08c379a0; // keccak256(\"Error(string)\")\r\n\r\n    function decodeError(bytes memory buffer)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        if (buffer.length == 0) return \"captured empty revert buffer\";\r\n        if (\r\n            uint32(uint256(bytes32(buffer.toSlice(0, 4).asWord()))) ==\r\n            REVERT_WITH_REASON_MAGIC\r\n        ) {\r\n            bytes memory revertMessageEncoded = buffer.toSlice(4).copy();\r\n            if (revertMessageEncoded.length == 0)\r\n                return \"captured empty revert message\";\r\n            string memory revertMessage =\r\n                abi.decode(revertMessageEncoded, (string));\r\n            return revertMessage;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n"
    },
    "contracts/util/SliceLib.sol": {
      "content": "pragma experimental ABIEncoderV2;\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport { MemcpyLib } from \"./MemcpyLib.sol\";\r\n\r\nlibrary SliceLib {\r\n  struct Slice {\r\n    uint256 data;\r\n    uint256 length;\r\n    uint256 offset;\r\n  }\r\n  function toPtr(bytes memory input, uint256 offset) internal pure returns (uint256 data) {\r\n    assembly {\r\n      data := add(input, add(offset, 0x20))\r\n    }\r\n  }\r\n  function toSlice(bytes memory input, uint256 offset, uint256 length) internal pure returns (Slice memory retval) {\r\n    retval.data = toPtr(input, offset);\r\n    retval.length = length;\r\n    retval.offset = offset;\r\n  }\r\n  function toSlice(bytes memory input) internal pure returns (Slice memory) {\r\n    return toSlice(input, 0);\r\n  }\r\n  function toSlice(bytes memory input, uint256 offset) internal pure returns (Slice memory) {\r\n    if (input.length < offset) offset = input.length;\r\n    return toSlice(input, offset, input.length - offset);\r\n  }\r\n  function toSlice(Slice memory input, uint256 offset, uint256 length) internal pure returns (Slice memory) {\r\n    return Slice({\r\n      data: input.data + offset,\r\n      offset: input.offset + offset,\r\n      length: length\r\n    });\r\n  }\r\n  function toSlice(Slice memory input, uint256 offset) internal pure returns (Slice memory) {\r\n    return toSlice(input, offset, input.length - offset);\r\n  }\r\n  function toSlice(Slice memory input) internal pure returns (Slice memory) {\r\n    return toSlice(input, 0);\r\n  }\r\n  function maskLastByteOfWordAt(uint256 data) internal pure returns (uint8 lastByte) {\r\n    assembly {\r\n      lastByte := and(mload(data), 0xff)\r\n    }\r\n  }\r\n  function get(Slice memory slice, uint256 index) internal pure returns (bytes1 result) {\r\n    return bytes1(maskLastByteOfWordAt(slice.data - 0x1f + index));\r\n  }\r\n  function setByteAt(uint256 ptr, uint8 value) internal pure {\r\n    assembly {\r\n      mstore8(ptr, value)\r\n    }\r\n  }\r\n  function set(Slice memory slice, uint256 index, uint8 value) internal pure {\r\n    setByteAt(slice.data + index, value);\r\n  }\r\n  function wordAt(uint256 ptr, uint256 length) internal pure returns (bytes32 word) {\r\n    assembly {\r\n      let mask := sub(shl(mul(length, 0x8), 0x1), 0x1)\r\n      word := and(mload(sub(ptr, sub(0x20, length))), mask)\r\n    }\r\n  }\r\n  function asWord(Slice memory slice) internal pure returns (bytes32 word) {\r\n    uint256 data = slice.data;\r\n    uint256 length = slice.length;\r\n    return wordAt(data, length);\r\n  }\r\n  function toDataStart(bytes memory input) internal pure returns (bytes32 start) {\r\n    assembly {\r\n      start := add(input, 0x20)\r\n    }\r\n  }\r\n  function copy(Slice memory slice) internal pure returns (bytes memory retval) {\r\n    uint256 length = slice.length;\r\n    retval = new bytes(length);\r\n    bytes32 src = bytes32(slice.data);\r\n    bytes32 dest = toDataStart(retval);\r\n    MemcpyLib.memcpy(dest, src, length);\r\n  }\r\n  function keccakAt(uint256 data, uint256 length) internal pure returns (bytes32 result) {\r\n    assembly {\r\n      result := keccak256(data, length)\r\n    }\r\n  }\r\n  function toKeccak(Slice memory slice) internal pure returns (bytes32 result) {\r\n    return keccakAt(slice.data, slice.length);\r\n  }\r\n}\r\n"
    },
    "contracts/util/MemcpyLib.sol": {
      "content": "pragma experimental ABIEncoderV2;\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nlibrary MemcpyLib {\r\n  function memcpy(bytes32 dest, bytes32 src, uint256 len) internal pure {\r\n    assembly {\r\n      for {} iszero(lt(len, 0x20)) { len := sub(len, 0x20) } {\r\n        mstore(dest, mload(src))\r\n        dest := add(dest, 0x20)\r\n        src := add(src, 0x20)\r\n      }\r\n      let mask := sub(shl(mul(sub(32, len), 8), 1), 1)\r\n      mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/staking/UpdateToLastImplLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\nimport { StakingControllerLib } from './StakingControllerLib.sol';\r\nimport {\r\n  SafeMathUpgradeable\r\n} from '@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol';\r\nimport {\r\n  MathUpgradeable as Math\r\n} from '@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol';\r\nimport { GetDisplayTierLib } from \"./GetDisplayTierLib.sol\";\r\n\r\nlibrary UpdateToLastImplLib {\r\n  using SafeMathUpgradeable for *;\r\n  struct UpdateToLastLocals {\r\n    uint256 cycleNumber;\r\n    uint256 weight;\r\n    uint256 multiplier;\r\n    uint256 lastDaySeen;\r\n    uint256 redeemable;\r\n    uint256 totalWeight;\r\n    uint256 daysToRedeem;\r\n    uint256 bonus;\r\n    uint256 i;\r\n  }\r\n  function _updateToLast(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    address user\r\n  ) internal {\r\n    UpdateToLastLocals memory locals;\r\n    StakingControllerLib.Cycle storage cycle = isolate.cycles[isolate.currentCycle];\r\n    if (cycle.users[user].seen) return;\r\n    StakingControllerLib.Cycle storage ptr = cycle;\r\n    locals.cycleNumber = isolate.currentCycle;\r\n    while (!ptr.users[user].seen && locals.cycleNumber > 0) {\r\n      ptr = isolate.cycles[--locals.cycleNumber];\r\n\r\n      if (ptr.users[user].seen) {\r\n        locals.weight = ptr.users[user].currentWeight;\r\n        locals.multiplier = ptr.users[user].multiplier;\r\n        cycle.users[user].seen = true;\r\n        cycle.users[user].currentWeight = locals.weight;\r\n        cycle.users[user].minimumWeight = locals.weight;\r\n        cycle.users[user].multiplier = locals.multiplier;\r\n        cycle.users[user].redeemable = ptr.users[user].redeemable;\r\n        cycle.users[user].start = ptr.users[user].start;\r\n        locals.lastDaySeen = ptr.users[user].daysClaimed;\r\n        locals.redeemable = 0;\r\n        locals.totalWeight = ptr.totalWeight;\r\n\r\n        if (locals.totalWeight > 0 && ptr.reserved > 0) {\r\n          locals.daysToRedeem = 0;\r\n          if (ptr.day - 1 > locals.lastDaySeen)\r\n            locals.daysToRedeem = uint256(ptr.day - 1).sub(locals.lastDaySeen);\r\n          locals.redeemable = locals.daysToRedeem.mul(isolate.inflateBy);\r\n          locals.redeemable = locals\r\n            .redeemable\r\n            .mul(locals.weight)\r\n            .mul(locals.multiplier)\r\n            .div(locals.totalWeight)\r\n            .div(1 ether);\r\n          if (locals.multiplier > 1 ether) {\r\n            locals.bonus = uint256(locals.multiplier.sub(1 ether))\r\n              .mul(locals.redeemable)\r\n              .div(locals.multiplier);\r\n            isolate.bonusesAccrued[user] = isolate.bonusesAccrued[user].add(locals.bonus);\r\n          }\r\n          cycle.users[user].redeemable = cycle.users[user].redeemable.add(\r\n            locals.redeemable\r\n          );\r\n        }\r\n\r\n        for (\r\n          locals.i = locals.cycleNumber + 1;\r\n          locals.i < isolate.currentCycle;\r\n          locals.i++\r\n        ) {\r\n          ptr = isolate.cycles[locals.i];\r\n          locals.totalWeight = ptr.totalWeight;\r\n          ptr.users[user].minimumWeight = locals.weight;\r\n          ptr.users[user].multiplier = locals.multiplier;\r\n          if (locals.totalWeight > 0 && ptr.reserved > 0) {\r\n            locals.redeemable = ptr\r\n              .reserved\r\n              .mul(locals.weight)\r\n              .mul(locals.multiplier)\r\n              .div(ptr.totalWeight)\r\n              .div(1 ether);\r\n            cycle.users[user].redeemable = cycle.users[user].redeemable.add(\r\n              locals.redeemable\r\n            );\r\n          }\r\n        }\r\n\r\n        return;\r\n      }\r\n    }\r\n    cycle.users[user].seen = true;\r\n    cycle.users[user].multiplier = 1 ether;\r\n  }\r\n\r\n  function _updateWeightsWithMultiplier(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    address user,\r\n    uint256 multiplier\r\n  ) internal returns (uint256) {\r\n    StakingControllerLib.Cycle storage cycle = isolate.cycles[isolate.currentCycle];\r\n    StakingControllerLib.User storage _sender = cycle.users[user];\r\n    StakingControllerLib.UpdateLocals memory locals;\r\n    locals.multiplier = multiplier;\r\n    locals.weight = Math.min(_sender.minimumWeight, _sender.currentWeight);\r\n    locals.prevMul = _sender.multiplier;\r\n    locals.prevRes = locals.weight.mul(locals.prevMul).div(1 ether);\r\n    locals.prevRawRes = _sender.currentWeight.mul(locals.prevMul).div(1 ether);\r\n    locals.nextRes = locals.weight.mul(locals.multiplier).div(1 ether);\r\n    locals.nextRawRes = _sender.currentWeight.mul(locals.multiplier).div(\r\n      1 ether\r\n    );\r\n    if (locals.multiplier != _sender.multiplier) {\r\n      _sender.multiplier = locals.multiplier;\r\n      if (cycle.totalWeight == locals.prevRes)\r\n        cycle.totalWeight = locals.nextRes;\r\n      else\r\n        cycle.totalWeight = cycle.totalWeight.sub(locals.prevRes).add(\r\n          locals.nextRes\r\n        );\r\n      if (cycle.totalRawWeight == locals.prevRawRes)\r\n        cycle.totalRawWeight = locals.nextRawRes;\r\n      else\r\n        cycle.totalRawWeight = cycle.totalRawWeight.sub(locals.prevRawRes).add(\r\n          locals.nextRawRes\r\n        );\r\n    }\r\n    return locals.multiplier;\r\n  }\r\n}\r\n"
    },
    "contracts/math/BancorFormulaLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\nlibrary BancorFormulaLib {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant _FIXED_1 = 0x080000000000000000000000000000000;\r\n\r\n    function FIXED_1() internal pure returns (uint256) {\r\n      return _FIXED_1;\r\n    }\r\n    function toFixed(uint256 x) internal pure returns (uint256 result) {\r\n      result = x.mul(_FIXED_1);\r\n    }\r\n    function optimalLog(uint256 x) internal pure returns (uint256) {\r\n        uint256 res = 0;\r\n\r\n        uint256 y;\r\n        uint256 z;\r\n        uint256 w;\r\n\r\n        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {\r\n            res += 0x40000000000000000000000000000000;\r\n            x = (x * _FIXED_1) / 0xd3094c70f034de4b96ff7d5b6f99fcd8;\r\n        } // add 1 / 2^1\r\n        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {\r\n            res += 0x20000000000000000000000000000000;\r\n            x = (x * _FIXED_1) / 0xa45af1e1f40c333b3de1db4dd55f29a7;\r\n        } // add 1 / 2^2\r\n        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {\r\n            res += 0x10000000000000000000000000000000;\r\n            x = (x * _FIXED_1) / 0x910b022db7ae67ce76b441c27035c6a1;\r\n        } // add 1 / 2^3\r\n        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {\r\n            res += 0x08000000000000000000000000000000;\r\n            x = (x * _FIXED_1) / 0x88415abbe9a76bead8d00cf112e4d4a8;\r\n        } // add 1 / 2^4\r\n        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {\r\n            res += 0x04000000000000000000000000000000;\r\n            x = (x * _FIXED_1) / 0x84102b00893f64c705e841d5d4064bd3;\r\n        } // add 1 / 2^5\r\n        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {\r\n            res += 0x02000000000000000000000000000000;\r\n            x = (x * _FIXED_1) / 0x8204055aaef1c8bd5c3259f4822735a2;\r\n        } // add 1 / 2^6\r\n        if (x >= 0x810100ab00222d861931c15e39b44e99) {\r\n            res += 0x01000000000000000000000000000000;\r\n            x = (x * _FIXED_1) / 0x810100ab00222d861931c15e39b44e99;\r\n        } // add 1 / 2^7\r\n        if (x >= 0x808040155aabbbe9451521693554f733) {\r\n            res += 0x00800000000000000000000000000000;\r\n            x = (x * _FIXED_1) / 0x808040155aabbbe9451521693554f733;\r\n        } // add 1 / 2^8\r\n\r\n        z = y = x - _FIXED_1;\r\n        w = (y * y) / _FIXED_1;\r\n        res +=\r\n            (z * (0x100000000000000000000000000000000 - y)) /\r\n            0x100000000000000000000000000000000;\r\n        z = (z * w) / _FIXED_1; // add y^01 / 01 - y^02 / 02\r\n        res +=\r\n            (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) /\r\n            0x200000000000000000000000000000000;\r\n        z = (z * w) / _FIXED_1; // add y^03 / 03 - y^04 / 04\r\n        res +=\r\n            (z * (0x099999999999999999999999999999999 - y)) /\r\n            0x300000000000000000000000000000000;\r\n        z = (z * w) / _FIXED_1; // add y^05 / 05 - y^06 / 06\r\n        res +=\r\n            (z * (0x092492492492492492492492492492492 - y)) /\r\n            0x400000000000000000000000000000000;\r\n        z = (z * w) / _FIXED_1; // add y^07 / 07 - y^08 / 08\r\n        res +=\r\n            (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) /\r\n            0x500000000000000000000000000000000;\r\n        z = (z * w) / _FIXED_1; // add y^09 / 09 - y^10 / 10\r\n        res +=\r\n            (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) /\r\n            0x600000000000000000000000000000000;\r\n        z = (z * w) / _FIXED_1; // add y^11 / 11 - y^12 / 12\r\n        res +=\r\n            (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) /\r\n            0x700000000000000000000000000000000;\r\n        z = (z * w) / _FIXED_1; // add y^13 / 13 - y^14 / 14\r\n        res +=\r\n            (z * (0x088888888888888888888888888888888 - y)) /\r\n            0x800000000000000000000000000000000; // add y^15 / 15 - y^16 / 16\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * @dev computes e ^ (x / _FIXED_1) * _FIXED_1\r\n     * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\r\n     * auto-generated via 'PrintFunctionOptimalExp.py'\r\n     * Detailed description:\r\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\r\n     * - The exponentiation of each binary exponent is given (pre-calculated)\r\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\r\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\r\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\r\n     */\r\n    function optimalExp(uint256 x) internal pure returns (uint256) {\r\n        uint256 res = 0;\r\n\r\n        uint256 y;\r\n        uint256 z;\r\n\r\n        z = y = x % 0x10000000000000000000000000000000; // get the input modulo 2^(-3)\r\n        z = (z * y) / _FIXED_1;\r\n        res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\r\n        z = (z * y) / _FIXED_1;\r\n        res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\r\n        z = (z * y) / _FIXED_1;\r\n        res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\r\n        z = (z * y) / _FIXED_1;\r\n        res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\r\n        z = (z * y) / _FIXED_1;\r\n        res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\r\n        z = (z * y) / _FIXED_1;\r\n        res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\r\n        z = (z * y) / _FIXED_1;\r\n        res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\r\n        z = (z * y) / _FIXED_1;\r\n        res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\r\n        z = (z * y) / _FIXED_1;\r\n        res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\r\n        z = (z * y) / _FIXED_1;\r\n        res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\r\n        z = (z * y) / _FIXED_1;\r\n        res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\r\n        z = (z * y) / _FIXED_1;\r\n        res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\r\n        z = (z * y) / _FIXED_1;\r\n        res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\r\n        z = (z * y) / _FIXED_1;\r\n        res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\r\n        z = (z * y) / _FIXED_1;\r\n        res += z * 0x000000000001c638; // add y^16 * (20! / 16!)\r\n        z = (z * y) / _FIXED_1;\r\n        res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\r\n        z = (z * y) / _FIXED_1;\r\n        res += z * 0x000000000000017c; // add y^18 * (20! / 18!)\r\n        z = (z * y) / _FIXED_1;\r\n        res += z * 0x0000000000000014; // add y^19 * (20! / 19!)\r\n        z = (z * y) / _FIXED_1;\r\n        res += z * 0x0000000000000001; // add y^20 * (20! / 20!)\r\n        res = res / 0x21c3677c82b40000 + y + _FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\r\n\r\n        if ((x & 0x010000000000000000000000000000000) != 0)\r\n            res =\r\n                (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) /\r\n                0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)\r\n        if ((x & 0x020000000000000000000000000000000) != 0)\r\n            res =\r\n                (res * 0x18ebef9eac820ae8682b9793ac6d1e778) /\r\n                0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)\r\n        if ((x & 0x040000000000000000000000000000000) != 0)\r\n            res =\r\n                (res * 0x1368b2fc6f9609fe7aceb46aa619baed5) /\r\n                0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)\r\n        if ((x & 0x080000000000000000000000000000000) != 0)\r\n            res =\r\n                (res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) /\r\n                0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)\r\n        if ((x & 0x100000000000000000000000000000000) != 0)\r\n            res =\r\n                (res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) /\r\n                0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)\r\n        if ((x & 0x200000000000000000000000000000000) != 0)\r\n            res =\r\n                (res * 0x00960aadc109e7a3bf4578099615711d7) /\r\n                0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)\r\n        if ((x & 0x400000000000000000000000000000000) != 0)\r\n            res =\r\n                (res * 0x0002bf84208204f5977f9a8cf01fdc307) /\r\n                0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)\r\n\r\n        return res;\r\n    }\r\n}\r\n"
    },
    "contracts/staking/GetDisplayTierLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport { StakingControllerLib } from \"./StakingControllerLib.sol\";\r\nimport { GetDisplayTierImplLib } from \"./GetDisplayTierImplLib.sol\";\r\n\r\nlibrary GetDisplayTierLib {\r\n  function getDisplayTier(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    uint256 tier,\r\n    uint256 newBalance\r\n  ) external view returns (uint256) {\r\n    return GetDisplayTierImplLib._getDisplayTier(isolate, tier, newBalance);\r\n  }\r\n}\r\n"
    },
    "contracts/staking/StakingControllerRedeploy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport {Initializable} from \"@openzeppelin/contracts/proxy/Initializable.sol\";\r\nimport {StakingControllerLib} from \"./StakingControllerLib.sol\";\r\nimport {ConnectToken as CNFI} from \"../token/CNFI.sol\";\r\nimport {sCNFI} from \"../token/sCNFI.sol\";\r\nimport {pCNFIFactoryLib} from \"../token/lib/pCNFIFactoryLib.sol\";\r\nimport {SafeMathUpgradeable} from \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\r\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol\";\r\nimport {pCNFI} from \"../token/pCNFI.sol\";\r\nimport {Create2} from \"@openzeppelin/contracts/utils/Create2.sol\";\r\nimport {FactoryLib} from \"../lib/FactoryLib.sol\";\r\nimport {ICNFI} from \"../interfaces/ICNFI.sol\";\r\nimport {CNFITreasury} from \"../treasury/CNFITreasury.sol\";\r\nimport {ViewExecutor} from \"../util/ViewExecutor.sol\";\r\nimport {StakingControllerTemplate} from \"./StakingControllerTemplate.sol\";\r\nimport {UpdateToLastLib} from \"./UpdateToLastLib.sol\";\r\nimport {UpdateRedeemableLib} from \"./UpdateRedeemableLib.sol\";\r\nimport {GetDisplayTierImplLib} from \"./GetDisplayTierImplLib.sol\";\r\nimport {StakingEventsLib} from \"./StakingEventsLib.sol\";\r\nimport {CalculateRewardsLib} from \"./CalculateRewardsLib.sol\";\r\nimport {CalculateRewardsImplLib} from \"./CalculateRewardsImplLib.sol\";\r\nimport {RevertConstantsLib} from \"../util/RevertConstantsLib.sol\";\r\nimport {BancorFormulaLib} from \"../math/BancorFormulaLib.sol\";\r\n\r\ncontract StakingControllerRedeploy is\r\n  StakingControllerTemplate,\r\n  ViewExecutor,\r\n  RevertConstantsLib\r\n{\r\n  using SafeMathUpgradeable for *;\r\n  using BancorFormulaLib for *;\r\n\r\n  function initialize(\r\n    address _cnfi,\r\n    address _sCnfi,\r\n    address _cnfiTreasury\r\n  ) public initializer {\r\n    __Ownable_init_unchained();\r\n    isolate.cnfi = ICNFI(_cnfi);\r\n    isolate.pCnfiImplementation = Create2.deploy(\r\n      0,\r\n      pCNFIFactoryLib.getSalt(),\r\n      pCNFIFactoryLib.getBytecode()\r\n    );\r\n    isolate.cnfiTreasury = CNFITreasury(_cnfiTreasury);\r\n    isolate.sCnfi = sCNFI(_sCnfi);\r\n    isolate.rewardInterval = 1 days;\r\n    isolate.cycleInterval = 180 days;\r\n  }\r\n\r\n  function govern(\r\n    uint256 _cycleInterval,\r\n    uint256 _rewardInterval,\r\n    uint256 _inflateBy,\r\n    uint256 _inflatepcnfiBy,\r\n    uint256 _baseUnstakePenalty,\r\n    uint256 _commitmentViolationPenalty,\r\n    uint256[] memory _multipliers,\r\n    uint256[] memory _cycles,\r\n    uint256[] memory _minimums\r\n  ) public onlyOwner {\r\n    if (_baseUnstakePenalty > 0)\r\n      isolate.baseUnstakePenalty = _baseUnstakePenalty;\r\n    if (_commitmentViolationPenalty > 0)\r\n      isolate.commitmentViolationPenalty = _commitmentViolationPenalty;\r\n    if (_cycleInterval > 0) {\r\n      isolate.cycleInterval = _cycleInterval;\r\n      isolate.nextCycleTime = block.timestamp + isolate.cycleInterval;\r\n    }\r\n    if (_rewardInterval > 0) {\r\n      isolate.rewardInterval = _rewardInterval;\r\n      isolate.nextTimestamp = block.timestamp + isolate.rewardInterval;\r\n    }\r\n    if (_inflateBy > 0) {\r\n      if (_inflateBy != isolate.inflateBy) {\r\n        isolate.inflateByChanged.push(isolate.currentDay);\r\n        isolate.inflateByValues[isolate.currentDay] = StakingControllerLib\r\n          .InflateByChanged(isolate.totalWeight, isolate.inflateBy);\r\n      }\r\n      isolate.inflateBy = _inflateBy;\r\n    }\r\n    if (_inflatepcnfiBy > 0) isolate.inflatepcnfiBy = _inflatepcnfiBy;\r\n    isolate.tiersLength = _multipliers.length + 1;\r\n    isolate.tiers[0].multiplier = uint256(1 ether);\r\n    for (uint256 i = 0; i < _multipliers.length; i++) {\r\n      isolate.tiers[i + 1] = StakingControllerLib.Tier(\r\n        _multipliers[i],\r\n        _minimums[i],\r\n        _cycles[i]\r\n      );\r\n    }\r\n  }\r\n\r\n  function fillFirstCycle() public onlyOwner {\r\n    _triggerCycle(true);\r\n  }\r\n\r\n  function _triggerCycle(bool force) internal {\r\n    if (force || block.timestamp > isolate.nextCycleTime) {\r\n      isolate.nextCycleTime = block.timestamp + isolate.cycleInterval;\r\n      uint256 _currentCycle = ++isolate.currentCycle;\r\n      isolate.cycles[_currentCycle].pCnfiToken = FactoryLib.create2Clone(\r\n        isolate.pCnfiImplementation,\r\n        uint256(\r\n          keccak256(abi.encodePacked(pCNFIFactoryLib.getSalt(), _currentCycle))\r\n        )\r\n      );\r\n      isolate.nextTimestamp = block.timestamp + isolate.rewardInterval;\r\n      isolate.pCnfi = pCNFI(isolate.cycles[_currentCycle].pCnfiToken);\r\n      isolate.pCnfi.initialize(_currentCycle);\r\n      isolate.cycles[_currentCycle].day = 1;\r\n      if (_currentCycle != 1) {\r\n        isolate.cycles[_currentCycle].totalWeight = isolate\r\n          .cycles[_currentCycle - 1]\r\n          .totalRawWeight;\r\n        isolate.cycles[_currentCycle].totalRawWeight = isolate\r\n          .cycles[_currentCycle - 1]\r\n          .totalRawWeight;\r\n      }\r\n    }\r\n  }\r\n\r\n  function determineMultiplier(address user, bool penaltyChange)\r\n    internal\r\n    returns (uint256)\r\n  {\r\n    uint256 currentBalance = isolate.sCnfi.balanceOf(user);\r\n    (uint256 multiplier, uint256 amountToBurn) = UpdateRedeemableLib\r\n      .determineMultiplier(isolate, penaltyChange, user, currentBalance);\r\n    if (amountToBurn > 0) isolate.sCnfi.burn(user, amountToBurn);\r\n    return multiplier;\r\n  }\r\n\r\n  function _updateToLast(address user) internal {\r\n    UpdateToLastLib.updateToLast(isolate, user);\r\n  }\r\n\r\n  function _updateCumulativeRewards(address user) internal {\r\n    UpdateRedeemableLib.updateCumulativeRewards(isolate, user);\r\n  }\r\n\r\n  function _updateWeightsWithMultiplier(address user)\r\n    internal\r\n    returns (uint256)\r\n  {\r\n    uint256 multiplier = determineMultiplier(user, false);\r\n\r\n    return\r\n      UpdateToLastLib.updateWeightsWithMultiplier(isolate, user, multiplier);\r\n  }\r\n\r\n  function _updateDailyStatsToLast(address user) internal {\r\n    UpdateRedeemableLib.updateDailyStatsToLast(isolate, user, 0, false, false);\r\n  }\r\n\r\n  function receiveSingularCallback(address sender) public {\r\n    if (sender != address(0x0)) {\r\n      _trackDailyRewards(false);\r\n      // _triggerCycle(false);\r\n      _updateCumulativeRewards(sender);\r\n      // _updateToLast(sender);\r\n      // _updateWeightsWithMultiplier(sender);\r\n      _updateDailyStatsToLast(sender);\r\n    }\r\n  }\r\n\r\n  function receiveCallback(address a, address b) public {\r\n    receiveSingularCallback(a);\r\n    receiveSingularCallback(b);\r\n  }\r\n\r\n  function calculateRewards(\r\n    address _user,\r\n    uint256 amount,\r\n    bool isView\r\n  ) internal returns (uint256 amountToRedeem, uint256 bonuses) {\r\n    receiveCallback(_user, address(0x0));\r\n    return CalculateRewardsLib.calculateRewards(isolate, _user, amount, isView);\r\n  }\r\n\r\n  function determineDailyMultiplier(address sender)\r\n    internal\r\n    returns (uint256 multiplier)\r\n  {\r\n    multiplier = UpdateRedeemableLib.determineDailyMultiplier(isolate, sender);\r\n  }\r\n\r\n  function _trackDailyRewards(bool force) internal {\r\n    StakingControllerLib.Cycle storage cycle = isolate.cycles[\r\n      isolate.currentCycle\r\n    ];\r\n\r\n    if (\r\n      force || (!cycle.canUnstake && block.timestamp > isolate.nextTimestamp)\r\n    ) {\r\n      uint256 daysMissed = 1;\r\n      if (block.timestamp > isolate.nextTimestamp) {\r\n        daysMissed = block\r\n          .timestamp\r\n          .sub(isolate.nextTimestamp)\r\n          .div(isolate.rewardInterval)\r\n          .add(1);\r\n      }\r\n      isolate.nextTimestamp = block.timestamp + isolate.rewardInterval;\r\n      cycle.reserved = cycle.reserved.add(isolate.inflateBy * daysMissed);\r\n      isolate.pCnfi.mint(\r\n        address(isolate.cnfiTreasury),\r\n        isolate.inflatepcnfiBy * daysMissed\r\n      );\r\n      for (uint256 i = 0; i < daysMissed; i++) {\r\n        cycle.cnfiRewards[cycle.day] = isolate.inflateBy;\r\n        cycle.day++;\r\n      }\r\n      isolate.cumulativeTotalWeight = isolate.cumulativeTotalWeight.add(\r\n        isolate.totalWeight * daysMissed\r\n      );\r\n\r\n      isolate.currentDay += daysMissed;\r\n    }\r\n  }\r\n\r\n  function _claim(address user)\r\n    public\r\n    view\r\n    returns (uint256 amountToRedeem, uint256 bonuses)\r\n  {\r\n    (amountToRedeem, bonuses) = CalculateRewardsImplLib._computeRewards(\r\n      isolate,\r\n      user\r\n    );\r\n  }\r\n\r\n  event RewardsClaimed(\r\n    address indexed user,\r\n    uint256 amountToRedeem,\r\n    uint256 bonuses\r\n  );\r\n\r\n  function claimRewards()\r\n    public\r\n    returns (uint256 amountToRedeem, uint256 bonuses)\r\n  {\r\n    return claimRewardsWithAmount(0);\r\n  }\r\n\r\n  function claimRewardsWithAmount(uint256 amount)\r\n    public\r\n    returns (uint256 amountToRedeem, uint256 bonuses)\r\n  {\r\n    (amountToRedeem, bonuses) = calculateRewards(msg.sender, amount, false);\r\n    isolate.cnfi.transferFrom(\r\n      address(isolate.cnfiTreasury),\r\n      msg.sender,\r\n      amountToRedeem\r\n    );\r\n    StakingEventsLib._emitRedeemed(msg.sender, amountToRedeem, bonuses);\r\n  }\r\n\r\n  function restakeRewardsWithAmount(uint256 amount, uint256 tier) public {\r\n    (uint256 amountToRedeem, uint256 bonuses) = calculateRewards(\r\n      msg.sender,\r\n      amount,\r\n      false\r\n    );\r\n    uint256 oldBalance = isolate.sCnfi.balanceOf(msg.sender);\r\n    StakingControllerLib.DailyUser storage user = isolate.dailyUsers[\r\n      msg.sender\r\n    ];\r\n\r\n    require(\r\n      (oldBalance + amountToRedeem >= isolate.tiers[tier].minimum &&\r\n        isolate.tiers[tier].minimum != 0) || tier == 0,\r\n      \"must provide more capital to commit to tier\"\r\n    );\r\n    if (isolate.lockCommitments[msg.sender] <= tier)\r\n      isolate.lockCommitments[msg.sender] = tier;\r\n    if (user.commitment <= tier) user.commitment = tier;\r\n\r\n    bool timeLocked = isolate.lockCommitments[msg.sender] > 0;\r\n    uint256 newBalance = oldBalance.add(amountToRedeem);\r\n    isolate.sCnfi.mint(msg.sender, amountToRedeem);\r\n    StakingEventsLib._emitRedeemed(msg.sender, amountToRedeem, bonuses);\r\n    tier = GetDisplayTierImplLib._getDisplayTier(isolate, tier, newBalance);\r\n    StakingEventsLib._emitStaked(\r\n      msg.sender,\r\n      amountToRedeem,\r\n      tier,\r\n      isolate.tiers[tier].minimum,\r\n      timeLocked\r\n    );\r\n    recalculateWeights(msg.sender, oldBalance, newBalance, false);\r\n  }\r\n\r\n  function recalculateWeights(\r\n    address sender,\r\n    uint256 oldBalance,\r\n    uint256 newBalance,\r\n    bool penalty\r\n  ) internal {\r\n    UpdateRedeemableLib.recalculateDailyWeights(\r\n      isolate,\r\n      sender,\r\n      newBalance,\r\n      penalty\r\n    );\r\n    /*UpdateRedeemableLib.recalculateWeights(\r\n      isolate,\r\n      sender,\r\n      oldBalance,\r\n      newBalance,\r\n      penalty\r\n    );\r\n    */\r\n  }\r\n\r\n  function stake(uint256 amount, uint256 commitmentTier) public {\r\n    require(commitmentTier < isolate.tiersLength);\r\n    receiveCallback(msg.sender, address(0x0));\r\n    uint256 oldBalance = isolate.sCnfi.balanceOf(msg.sender);\r\n    uint256 newBalance = oldBalance.add(amount);\r\n    isolate.cnfi.transferFrom(\r\n      msg.sender,\r\n      address(isolate.cnfiTreasury),\r\n      amount\r\n    );\r\n    isolate.sCnfi.mint(msg.sender, amount);\r\n    require(\r\n      (oldBalance + amount >= isolate.tiers[commitmentTier].minimum &&\r\n        isolate.tiers[commitmentTier].minimum != 0) || commitmentTier == 0,\r\n      \"must provide more capital to commit to tier\"\r\n    );\r\n    if (commitmentTier >= isolate.dailyUsers[msg.sender].commitment)\r\n      isolate.lockCommitments[msg.sender] = commitmentTier;\r\n    bool isLocked = isolate.lockCommitments[msg.sender] > 0;\r\n    StakingControllerLib.DailyUser storage user = isolate.dailyUsers[\r\n      msg.sender\r\n    ];\r\n    if (commitmentTier >= user.commitment) {\r\n      user.commitment = commitmentTier;\r\n      if (user.commitment == 0) isolate.dailyBonusesAccrued[msg.sender] = 0;\r\n    }\r\n    commitmentTier = GetDisplayTierImplLib._getDisplayTier(\r\n      isolate,\r\n      commitmentTier,\r\n      newBalance\r\n    );\r\n    StakingEventsLib._emitStaked(\r\n      msg.sender,\r\n      amount,\r\n      commitmentTier - 1,\r\n      isolate.tiers[commitmentTier].minimum,\r\n      isLocked\r\n    );\r\n    recalculateWeights(msg.sender, oldBalance, newBalance, false);\r\n  }\r\n\r\n  function unstake(uint256 amount) public returns (uint256 withdrawable) {\r\n    receiveCallback(msg.sender, address(0x0));\r\n    uint256 oldBalance = isolate.sCnfi.balanceOf(msg.sender);\r\n    uint256 newBalance;\r\n    if (oldBalance > amount) newBalance = oldBalance.sub(amount);\r\n    else newBalance = 0;\r\n\r\n    uint256 beforeRecalculatedBalance = isolate.sCnfi.balanceOf(msg.sender);\r\n    recalculateWeights(msg.sender, oldBalance, newBalance, true);\r\n    uint256 currentBalance = isolate.sCnfi.balanceOf(msg.sender);\r\n    uint256 amountLeft = Math.min(currentBalance, amount);\r\n    isolate.sCnfi.burn(msg.sender, amountLeft);\r\n    StakingEventsLib._emitUnstaked(\r\n      msg.sender,\r\n      amountLeft,\r\n      beforeRecalculatedBalance -\r\n        Math.min(beforeRecalculatedBalance, isolate.sCnfi.balanceOf(msg.sender))\r\n    );\r\n    withdrawable = amountLeft\r\n      .mul(uint256(1 ether).sub(isolate.baseUnstakePenalty))\r\n      .div(uint256(1 ether));\r\n    isolate.cnfi.transferFrom(\r\n      address(isolate.cnfiTreasury),\r\n      msg.sender,\r\n      withdrawable\r\n    );\r\n  }\r\n}\r\n"
    },
    "@openzeppelin/contracts/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !Address.isContract(address(this));\n    }\n}\n"
    },
    "contracts/token/CNFI.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\r\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport {IStakingController} from \"../interfaces/IStakingController.sol\";\r\n\r\ncontract ConnectToken is ERC20Upgradeable, OwnableUpgradeable {\r\n  uint256 public unlockAt;\r\n  mapping(address => bool) authorizedBeforeUnlock;\r\n  bytes32 constant STAKING_CONTROLLER_SLOT = keccak256(\"staking-controller\");\r\n\r\n  function initialize() public initializer {\r\n    __Ownable_init_unchained();\r\n  }\r\n\r\n  function getStakingController() public view returns (address returnValue) {\r\n    bytes32 local = STAKING_CONTROLLER_SLOT;\r\n    assembly {\r\n      returnValue := and(\r\n        0xffffffffffffffffffffffffffffffffffffffff,\r\n        sload(local)\r\n      )\r\n    }\r\n  }\r\n\r\n  function setStakingController(address) public virtual {\r\n    assembly {\r\n      sstore(0x59195, 0x1)\r\n    }\r\n  } // stub\r\n\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) public virtual override returns (bool) {\r\n    address own = getStakingController();\r\n    if (own == msg.sender) _approve(from, own, amount);\r\n    require(from != 0x2C6900b24221dE2B4A45c8c89482fFF96FFB7E55, \"not allowed\");\r\n    return super.transferFrom(from, to, amount);\r\n  }\r\n\r\n  function transfer(address recipient, uint256 amount)\r\n    public\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    require(\r\n      msg.sender != 0x2C6900b24221dE2B4A45c8c89482fFF96FFB7E55,\r\n      \"not allowed\"\r\n    );\r\n    return super.transfer(recipient, amount);\r\n  }\r\n}\r\n"
    },
    "contracts/token/lib/pCNFIFactoryLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport {pCNFI} from \"../pCNFI.sol\";\r\n\r\nlibrary pCNFIFactoryLib {\r\n    bytes32 constant PCNFI_SALT = keccak256(\"connect-pcnfi\");\r\n\r\n    function getSalt() external pure returns (bytes32 result) {\r\n        result = PCNFI_SALT;\r\n    }\r\n\r\n    function getBytecode() external pure returns (bytes memory result) {\r\n        result = type(pCNFI).creationCode;\r\n    }\r\n}\r\n"
    },
    "contracts/lib/FactoryLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport { Create2 } from \"@openzeppelin/contracts/utils/Create2.sol\";\r\n\r\nlibrary FactoryLib {\r\n  function computeCreationCode(address target) internal view returns (bytes memory clone) {\r\n    clone = computeCreationCode(address(this), target);\r\n  }\r\n  function computeCreationCode(address deployer, address target) internal pure returns (bytes memory clone) {\r\n      bytes memory consData = abi.encodeWithSignature(\"cloneConstructor(bytes)\", new bytes(0));\r\n      clone = new bytes(99 + consData.length);\r\n      assembly {\r\n        mstore(add(clone, 0x20),\r\n           0x3d3d606380380380913d393d73bebebebebebebebebebebebebebebebebebebe)\r\n        mstore(add(clone, 0x2d),\r\n           mul(deployer, 0x01000000000000000000000000))\r\n        mstore(add(clone, 0x41),\r\n           0x5af4602a57600080fd5b602d8060366000396000f3363d3d373d3d3d363d73be)\r\n           mstore(add(clone, 0x60),\r\n           mul(target, 0x01000000000000000000000000))\r\n        mstore(add(clone, 116),\r\n           0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n      }\r\n      for (uint256 i = 0; i < consData.length; i++) {\r\n        clone[i + 99] = consData[i];\r\n      }\r\n  }\r\n  function deriveInstanceAddress(address target, bytes32 salt) internal view returns (address) {\r\n    return Create2.computeAddress(salt, keccak256(computeCreationCode(target)));\r\n  }\r\n  function deriveInstanceAddress(address from, address target, bytes32 salt) internal pure returns (address) {\r\n     return Create2.computeAddress(salt, keccak256(computeCreationCode(from, target)), from);\r\n  }\r\n  function create2Clone(address target, uint saltNonce) internal returns (address result) {\r\n    bytes memory clone = computeCreationCode(target);\r\n    bytes32 salt = bytes32(saltNonce);\r\n      \r\n    assembly {\r\n      let len := mload(clone)\r\n      let data := add(clone, 0x20)\r\n      result := create2(0, data, len, salt)\r\n    }\r\n      \r\n    require(result != address(0), \"create2 failed\");\r\n  }\r\n}\r\n"
    },
    "contracts/staking/UpdateToLastLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\nimport { StakingControllerLib } from \"./StakingControllerLib.sol\";\r\nimport { UpdateToLastImplLib } from \"./UpdateToLastImplLib.sol\";\r\n\r\nlibrary UpdateToLastLib {\r\n  function updateToLast(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    address user\r\n  ) external {\r\n    UpdateToLastImplLib._updateToLast(isolate, user);\r\n  }\r\n  function updateWeightsWithMultiplier(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    address user,\r\n    uint256 multiplier\r\n  ) external returns (uint256) {\r\n    return UpdateToLastImplLib._updateWeightsWithMultiplier(isolate, user, multiplier);\r\n  }\r\n}\r\n"
    },
    "contracts/staking/UpdateRedeemableLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport { SafeMathUpgradeable } from \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\r\nimport { StakingControllerLib } from \"./StakingControllerLib.sol\";\r\nimport { MathUpgradeable as Math } from \"@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol\";\r\nimport { UpdateToLastLib } from \"./UpdateToLastLib.sol\";\r\nimport { sCNFI } from \"../token/sCNFI.sol\";\r\nimport { ComputeCyclesHeldLib } from \"./ComputeCyclesHeldLib.sol\";\r\nimport { UpdateRedeemableImplLib } from \"./UpdateRedeemableImplLib.sol\";\r\n\r\nlibrary UpdateRedeemableLib {\r\n  using SafeMathUpgradeable for *;\r\n\r\n  function determineMultiplier(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    bool penaltyChange,\r\n    address user,\r\n    uint256 currentBalance\r\n  ) external returns (uint256 multiplier, uint256 amountToBurn) {\r\n    (multiplier, amountToBurn) = UpdateRedeemableImplLib._determineMultiplier(isolate, penaltyChange, user, currentBalance);\r\n  }\r\n  function updateCumulativeRewards(StakingControllerLib.Isolate storage isolate, address _user) internal {\r\n    UpdateRedeemableImplLib._updateCumulativeRewards(isolate, _user);\r\n  }\r\n  function updateRedeemable(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    StakingControllerLib.DailyUser storage user,\r\n    uint256 multiplier\r\n  ) external view returns (uint256 redeemable, uint256 bonuses) {\r\n    (redeemable, bonuses) = UpdateRedeemableImplLib._updateRedeemable(isolate, user, multiplier);\r\n  }\r\n  function updateDailyStatsToLast(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    address sender,\r\n    uint256 weight,\r\n    bool penalize,\r\n    bool init\r\n  ) external returns (uint256 redeemable, uint256 bonuses) {\r\n    (redeemable, bonuses) = UpdateRedeemableImplLib._updateDailyStatsToLast(isolate, sender, weight, penalize, init);\r\n  }\r\n\r\n  function recalculateDailyWeights(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    address sender,\r\n    uint256 newBalance,\r\n    bool penalty\r\n  ) external {\r\n    UpdateRedeemableImplLib._recalculateDailyWeights(isolate, sender, newBalance, penalty);\r\n  }\r\n\r\n  function recalculateWeights(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    address sender,\r\n    uint256 oldBalance,\r\n    uint256 newBalance,\r\n    bool penalty\r\n  ) external {\r\n    UpdateRedeemableImplLib._recalculateWeights(isolate, sender, oldBalance, newBalance, penalty);\r\n  }\r\n  function determineDailyMultiplier(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    address sender\r\n  ) external returns (uint256 multiplier) {\r\n    multiplier = UpdateRedeemableImplLib._determineDailyMultiplier(isolate, sender);\r\n  }\r\n}\r\n"
    },
    "contracts/staking/StakingEventsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nlibrary StakingEventsLib {\r\n  event Redeemed(address indexed user, uint256 amountToRedeem, uint256 bonuses);\r\n  function _emitRedeemed(address user, uint256 amountToRedeem, uint256 bonuses) internal {\r\n    emit Redeemed(user, amountToRedeem, bonuses);\r\n  }\r\n  event Staked(\r\n    address indexed user,\r\n    uint256 amount,\r\n    uint256 indexed commitmentTier,\r\n    uint256 minimum,\r\n    bool timeLocked\r\n  );\r\n  function _emitStaked(address user, uint256 amount, uint256 commitmentTier, uint256 minimum, bool timeLocked) internal {\r\n    emit Staked(user, amount, commitmentTier, minimum, timeLocked);\r\n  }\r\n  event Unstaked(address indexed user, uint256 amount, uint256 slashed);\r\n  function _emitUnstaked(address user, uint256 amount, uint256 slashed) internal {\r\n    emit Unstaked(user, amount, slashed);\r\n  }\r\n}\r\n"
    },
    "contracts/staking/CalculateRewardsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport {\r\n  SafeMathUpgradeable\r\n} from '@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol';\r\nimport { CalculateRewardsImplLib } from './CalculateRewardsImplLib.sol';\r\nimport { StakingControllerLib } from './StakingControllerLib.sol';\r\n\r\nlibrary CalculateRewardsLib {\r\n  using SafeMathUpgradeable for *;\r\n\r\n  function calculateRewards(\r\n    StakingControllerLib.Isolate storage isolate,\r\n    address _user,\r\n    uint256 amt,\r\n    bool isView\r\n  ) external returns (uint256 amountToRedeem, uint256 bonuses) {\r\n    (amountToRedeem, bonuses) = CalculateRewardsImplLib._calculateRewards(\r\n      isolate,\r\n      _user,\r\n      amt,\r\n      isView\r\n    );\r\n  }\r\n}\r\n"
    },
    "contracts/util/RevertConstantsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\ncontract RevertConstantsLib {\r\n    bytes4 constant REVERT_MAGIC = 0x08c379a0;\r\n    bytes4 constant REVERT_MASK = 0xffffffff;\r\n}\r\n"
    },
    "contracts/view/Query.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {StakingControllerRedeploy as StakingController} from \"../staking/StakingControllerRedeploy.sol\";\r\nimport {StakingControllerLib} from \"../staking/StakingControllerLib.sol\";\r\nimport {ViewExecutor} from \"../util/ViewExecutor.sol\";\r\nimport {Viewer} from \"./Viewer.sol\";\r\nimport {RevertCaptureLib} from \"../util/RevertCaptureLib.sol\";\r\nimport {BytesManip} from \"../util/Bytes.sol\";\r\n\r\ncontract Query is Viewer {\r\n  using BytesManip for *;\r\n\r\n  constructor(address sc, address user) public {\r\n    StakingController(sc).receiveCallback(user, address(0x0));\r\n    address viewLayer = address(new Viewer());\r\n    bytes memory response = StakingController(sc).query(\r\n      viewLayer,\r\n      abi.encodeWithSelector(Viewer.render.selector, user)\r\n    );\r\n    bytes memory returnData = abi.encode(response, 0, 0, block.timestamp);\r\n    assembly {\r\n      return(add(0x20, returnData), mload(returnData))\r\n    }\r\n  }\r\n\r\n  function decodeResponse()\r\n    public\r\n    returns (\r\n      bytes memory,\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    )\r\n  {}\r\n}\r\n"
    },
    "contracts/util/Bytes.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\r\n/*\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Gonalo S <goncalo.sa@consensys.net>\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\r\n */\r\n\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\nimport {Memory} from \"./Memory.sol\";\r\n\r\nlibrary BytesManip {\r\n    function concat(bytes memory _preBytes, bytes memory _postBytes)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add\r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(\r\n                0x40,\r\n                and(\r\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n                    not(31) // Round down to the nearest 32 bytes.\r\n                )\r\n            )\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint256 _start,\r\n        uint256 _length\r\n    ) internal pure returns (bytes memory) {\r\n        require(_length + 31 >= _length, \"slice_overflow\");\r\n        require(_start + _length >= _start, \"slice_overflow\");\r\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n                case 0 {\r\n                    // Get a location of some free memory and store it in tempBytes as\r\n                    // Solidity does for memory variables.\r\n                    tempBytes := mload(0x40)\r\n\r\n                    // The first word of the slice result is potentially a partial\r\n                    // word read from the original array. To read it, we calculate\r\n                    // the length of that partial word and start copying that many\r\n                    // bytes into the array. The first word we copy will start with\r\n                    // data we don't care about, but the last `lengthmod` bytes will\r\n                    // land at the beginning of the contents of the new array. When\r\n                    // we're done copying, we overwrite the full first word with\r\n                    // the actual length of the slice.\r\n                    let lengthmod := and(_length, 31)\r\n\r\n                    // The multiplication in the next line is necessary\r\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                    // the following copy loop was copying the origin's length\r\n                    // and then ending prematurely not copying everything it should.\r\n                    let mc := add(\r\n                        add(tempBytes, lengthmod),\r\n                        mul(0x20, iszero(lengthmod))\r\n                    )\r\n                    let end := add(mc, _length)\r\n\r\n                    for {\r\n                        // The multiplication in the next line has the same exact purpose\r\n                        // as the one above.\r\n                        let cc := add(\r\n                            add(\r\n                                add(_bytes, lengthmod),\r\n                                mul(0x20, iszero(lengthmod))\r\n                            ),\r\n                            _start\r\n                        )\r\n                    } lt(mc, end) {\r\n                        mc := add(mc, 0x20)\r\n                        cc := add(cc, 0x20)\r\n                    } {\r\n                        mstore(mc, mload(cc))\r\n                    }\r\n\r\n                    mstore(tempBytes, _length)\r\n\r\n                    //update free-memory pointer\r\n                    //allocating the array padded to 32 bytes like the compiler does now\r\n                    mstore(0x40, and(add(mc, 31), not(31)))\r\n                }\r\n                //if we want a zero-length slice let's just return a zero-length array\r\n                default {\r\n                    tempBytes := mload(0x40)\r\n                    //zero out the 32 bytes slice we are about to return\r\n                    //we need to do it because Solidity does not garbage collect\r\n                    mstore(tempBytes, 0)\r\n\r\n                    mstore(0x40, add(tempBytes, 0x20))\r\n                }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n}\r\n"
    },
    "contracts/util/Memory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nlibrary Memory {\r\n    // Size of a word, in bytes.\r\n    uint256 internal constant WORD_SIZE = 32;\r\n    // Size of the header of a 'bytes' array.\r\n    uint256 internal constant BYTES_HEADER_SIZE = 32;\r\n    // Address of the free memory pointer.\r\n    uint256 internal constant FREE_MEM_PTR = 0x40;\r\n\r\n    // Compares the 'len' bytes starting at address 'addr' in memory with the 'len'\r\n    // bytes starting at 'addr2'.\r\n    // Returns 'true' if the bytes are the same, otherwise 'false'.\r\n    function equals(\r\n        uint256 addr,\r\n        uint256 addr2,\r\n        uint256 len\r\n    ) internal pure returns (bool equal) {\r\n        assembly {\r\n            equal := eq(keccak256(addr, len), keccak256(addr2, len))\r\n        }\r\n    }\r\n\r\n    // Compares the 'len' bytes starting at address 'addr' in memory with the bytes stored in\r\n    // 'bts'. It is allowed to set 'len' to a lower value then 'bts.length', in which case only\r\n    // the first 'len' bytes will be compared.\r\n    // Requires that 'bts.length >= len'\r\n    function equals(\r\n        uint256 addr,\r\n        uint256 len,\r\n        bytes memory bts\r\n    ) internal pure returns (bool equal) {\r\n        require(bts.length >= len);\r\n        uint256 addr2;\r\n        assembly {\r\n            addr2 := add(\r\n                bts,\r\n                /*BYTES_HEADER_SIZE*/\r\n                32\r\n            )\r\n        }\r\n        return equals(addr, addr2, len);\r\n    }\r\n\r\n    // Allocates 'numBytes' bytes in memory. This will prevent the Solidity compiler\r\n    // from using this area of memory. It will also initialize the area by setting\r\n    // each byte to '0'.\r\n    function allocate(uint256 numBytes) internal pure returns (uint256 addr) {\r\n        // Take the current value of the free memory pointer, and update.\r\n        assembly {\r\n            addr := mload(\r\n                /*FREE_MEM_PTR*/\r\n                0x40\r\n            )\r\n            mstore(\r\n                /*FREE_MEM_PTR*/\r\n                0x40,\r\n                add(addr, numBytes)\r\n            )\r\n        }\r\n        uint256 words = (numBytes + WORD_SIZE - 1) / WORD_SIZE;\r\n        for (uint256 i = 0; i < words; i++) {\r\n            assembly {\r\n                mstore(\r\n                    add(\r\n                        addr,\r\n                        mul(\r\n                            i,\r\n                            /*WORD_SIZE*/\r\n                            32\r\n                        )\r\n                    ),\r\n                    0\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    // Copy 'len' bytes from memory address 'src', to address 'dest'.\r\n    // This function does not check the or destination, it only copies\r\n    // the bytes.\r\n    function copy(\r\n        uint256 src,\r\n        uint256 dest,\r\n        uint256 len\r\n    ) internal pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += WORD_SIZE;\r\n            src += WORD_SIZE;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint256 mask = 256**(WORD_SIZE - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    // Returns a memory pointer to the provided bytes array.\r\n    function ptr(bytes memory bts) internal pure returns (uint256 addr) {\r\n        assembly {\r\n            addr := bts\r\n        }\r\n    }\r\n\r\n    // Returns a memory pointer to the data portion of the provided bytes array.\r\n    function dataPtr(bytes memory bts) internal pure returns (uint256 addr) {\r\n        assembly {\r\n            addr := add(\r\n                bts,\r\n                /*BYTES_HEADER_SIZE*/\r\n                32\r\n            )\r\n        }\r\n    }\r\n\r\n    // This function does the same as 'dataPtr(bytes memory)', but will also return the\r\n    // length of the provided bytes array.\r\n    function fromBytes(bytes memory bts)\r\n        internal\r\n        pure\r\n        returns (uint256 addr, uint256 len)\r\n    {\r\n        len = bts.length;\r\n        assembly {\r\n            addr := add(\r\n                bts,\r\n                /*BYTES_HEADER_SIZE*/\r\n                32\r\n            )\r\n        }\r\n    }\r\n\r\n    // Creates a 'bytes memory' variable from the memory address 'addr', with the\r\n    // length 'len'. The function will allocate new memory for the bytes array, and\r\n    // the 'len bytes starting at 'addr' will be copied into that new memory.\r\n    function toBytes(uint256 addr, uint256 len)\r\n        internal\r\n        pure\r\n        returns (bytes memory bts)\r\n    {\r\n        bts = new bytes(len);\r\n        uint256 btsptr;\r\n        assembly {\r\n            btsptr := add(\r\n                bts,\r\n                /*BYTES_HEADER_SIZE*/\r\n                32\r\n            )\r\n        }\r\n        copy(addr, btsptr, len);\r\n    }\r\n\r\n    // Get the word stored at memory address 'addr' as a 'uint'.\r\n    function toUint(uint256 addr) internal pure returns (uint256 n) {\r\n        assembly {\r\n            n := mload(addr)\r\n        }\r\n    }\r\n\r\n    // Get the word stored at memory address 'addr' as a 'bytes32'.\r\n    function toBytes32(uint256 addr) internal pure returns (bytes32 bts) {\r\n        assembly {\r\n            bts := mload(addr)\r\n        }\r\n    }\r\n\r\n    /*\r\n    // Get the byte stored at memory address 'addr' as a 'byte'.\r\n    function toByte(uint addr, uint8 index) internal pure returns (byte b) {\r\n        require(index < WORD_SIZE);\r\n        uint8 n;\r\n        assembly {\r\n            n := byte(index, mload(addr))\r\n        }\r\n        b = byte(n);\r\n    }\r\n    */\r\n}\r\n"
    },
    "contracts/staking/StakingController.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport {Initializable} from \"@openzeppelin/contracts/proxy/Initializable.sol\";\r\nimport {StakingControllerLib} from \"./StakingControllerLib.sol\";\r\nimport {ConnectToken as CNFI} from \"../token/CNFI.sol\";\r\nimport {sCNFI} from \"../token/sCNFI.sol\";\r\nimport {pCNFIFactoryLib} from \"../token/lib/pCNFIFactoryLib.sol\";\r\nimport {SafeMathUpgradeable} from \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\r\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol\";\r\nimport {pCNFI} from \"../token/pCNFI.sol\";\r\nimport {Create2} from \"@openzeppelin/contracts/utils/Create2.sol\";\r\nimport {FactoryLib} from \"../lib/FactoryLib.sol\";\r\nimport {ICNFI} from \"../interfaces/ICNFI.sol\";\r\nimport {CNFITreasury} from \"../treasury/CNFITreasury.sol\";\r\nimport {ViewExecutor} from \"../util/ViewExecutor.sol\";\r\nimport {StakingControllerTemplate} from \"./StakingControllerTemplate.sol\";\r\nimport {UpdateToLastLib} from \"./UpdateToLastLib.sol\";\r\nimport {UpdateRedeemableLib} from \"./UpdateRedeemableLib.sol\";\r\nimport {GetDisplayTierImplLib} from \"./GetDisplayTierImplLib.sol\";\r\nimport {StakingEventsLib} from \"./StakingEventsLib.sol\";\r\nimport {CalculateRewardsLib} from \"./CalculateRewardsLib.sol\";\r\nimport {CalculateRewardsImplLib} from \"./CalculateRewardsImplLib.sol\";\r\nimport {RevertConstantsLib} from \"../util/RevertConstantsLib.sol\";\r\nimport {BancorFormulaLib} from \"../math/BancorFormulaLib.sol\";\r\n\r\ncontract StakingController is\r\n  StakingControllerTemplate,\r\n  ViewExecutor,\r\n  RevertConstantsLib\r\n{\r\n  using SafeMathUpgradeable for *;\r\n  using BancorFormulaLib for *;\r\n\r\n  function initialize(\r\n    address _cnfi,\r\n    address _sCnfi,\r\n    address _cnfiTreasury\r\n  ) public initializer {\r\n    __Ownable_init_unchained();\r\n    isolate.cnfi = ICNFI(_cnfi);\r\n    isolate.pCnfiImplementation = Create2.deploy(\r\n      0,\r\n      pCNFIFactoryLib.getSalt(),\r\n      pCNFIFactoryLib.getBytecode()\r\n    );\r\n    isolate.cnfiTreasury = CNFITreasury(_cnfiTreasury);\r\n    isolate.sCnfi = sCNFI(_sCnfi);\r\n    isolate.rewardInterval = 1 days;\r\n    isolate.cycleInterval = 180 days;\r\n  }\r\n\r\n  function govern(\r\n    uint256 _cycleInterval,\r\n    uint256 _rewardInterval,\r\n    uint256 _inflateBy,\r\n    uint256 _inflatepcnfiBy,\r\n    uint256 _baseUnstakePenalty,\r\n    uint256 _commitmentViolationPenalty,\r\n    uint256[] memory _multipliers,\r\n    uint256[] memory _cycles,\r\n    uint256[] memory _minimums\r\n  ) public onlyOwner {\r\n    if (_baseUnstakePenalty > 0)\r\n      isolate.baseUnstakePenalty = _baseUnstakePenalty;\r\n    if (_commitmentViolationPenalty > 0)\r\n      isolate.commitmentViolationPenalty = _commitmentViolationPenalty;\r\n    if (_cycleInterval > 0) {\r\n      isolate.cycleInterval = _cycleInterval;\r\n      isolate.nextCycleTime = block.timestamp + isolate.cycleInterval;\r\n    }\r\n    if (_rewardInterval > 0) {\r\n      isolate.rewardInterval = _rewardInterval;\r\n      isolate.nextTimestamp = block.timestamp + isolate.rewardInterval;\r\n    }\r\n    if (_inflateBy > 0) {\r\n      if (_inflateBy != isolate.inflateBy) {\r\n        isolate.inflateByChanged.push(isolate.currentDay);\r\n        isolate.inflateByValues[isolate.currentDay] = StakingControllerLib\r\n          .InflateByChanged(isolate.totalWeight, isolate.inflateBy);\r\n      }\r\n      isolate.inflateBy = _inflateBy;\r\n    }\r\n    if (_inflatepcnfiBy > 0) isolate.inflatepcnfiBy = _inflatepcnfiBy;\r\n    isolate.tiersLength = _multipliers.length + 1;\r\n    isolate.tiers[0].multiplier = uint256(1 ether);\r\n    for (uint256 i = 0; i < _multipliers.length; i++) {\r\n      isolate.tiers[i + 1] = StakingControllerLib.Tier(\r\n        _multipliers[i],\r\n        _minimums[i],\r\n        _cycles[i]\r\n      );\r\n    }\r\n  }\r\n\r\n  function fillFirstCycle() public onlyOwner {\r\n    _triggerCycle(true);\r\n  }\r\n\r\n  function _triggerCycle(bool force) internal {\r\n    if (force || block.timestamp > isolate.nextCycleTime) {\r\n      isolate.nextCycleTime = block.timestamp + isolate.cycleInterval;\r\n      uint256 _currentCycle = ++isolate.currentCycle;\r\n      isolate.cycles[_currentCycle].pCnfiToken = FactoryLib.create2Clone(\r\n        isolate.pCnfiImplementation,\r\n        uint256(\r\n          keccak256(abi.encodePacked(pCNFIFactoryLib.getSalt(), _currentCycle))\r\n        )\r\n      );\r\n      isolate.nextTimestamp = block.timestamp + isolate.rewardInterval;\r\n      isolate.pCnfi = pCNFI(isolate.cycles[_currentCycle].pCnfiToken);\r\n      isolate.pCnfi.initialize(_currentCycle);\r\n      isolate.cycles[_currentCycle].day = 1;\r\n      if (_currentCycle != 1) {\r\n        isolate.cycles[_currentCycle].totalWeight = isolate\r\n          .cycles[_currentCycle - 1]\r\n          .totalRawWeight;\r\n        isolate.cycles[_currentCycle].totalRawWeight = isolate\r\n          .cycles[_currentCycle - 1]\r\n          .totalRawWeight;\r\n      }\r\n    }\r\n  }\r\n\r\n  function determineMultiplier(address user, bool penaltyChange)\r\n    internal\r\n    returns (uint256)\r\n  {\r\n    uint256 currentBalance = isolate.sCnfi.balanceOf(user);\r\n    (uint256 multiplier, uint256 amountToBurn) = UpdateRedeemableLib\r\n      .determineMultiplier(isolate, penaltyChange, user, currentBalance);\r\n    if (amountToBurn > 0) isolate.sCnfi.burn(user, amountToBurn);\r\n    return multiplier;\r\n  }\r\n\r\n  function _updateToLast(address user) internal {\r\n    UpdateToLastLib.updateToLast(isolate, user);\r\n  }\r\n\r\n  function _updateCumulativeRewards(address user) internal {\r\n    UpdateRedeemableLib.updateCumulativeRewards(isolate, user);\r\n  }\r\n\r\n  function _updateWeightsWithMultiplier(address user)\r\n    internal\r\n    returns (uint256)\r\n  {\r\n    uint256 multiplier = determineMultiplier(user, false);\r\n\r\n    return\r\n      UpdateToLastLib.updateWeightsWithMultiplier(isolate, user, multiplier);\r\n  }\r\n\r\n  function _updateDailyStatsToLast(address user) internal {\r\n    UpdateRedeemableLib.updateDailyStatsToLast(isolate, user, 0, false, false);\r\n  }\r\n\r\n  function receiveSingularCallback(address sender) public {\r\n    if (sender != address(0x0)) {\r\n      _trackDailyRewards(false);\r\n      _triggerCycle(false);\r\n      _updateCumulativeRewards(sender);\r\n      _updateToLast(sender);\r\n      _updateWeightsWithMultiplier(sender);\r\n      _updateDailyStatsToLast(sender);\r\n    }\r\n  }\r\n\r\n  function receiveCallback(address a, address b) public {\r\n    receiveSingularCallback(a);\r\n    receiveSingularCallback(b);\r\n  }\r\n\r\n  function calculateRewards(\r\n    address _user,\r\n    uint256 amount,\r\n    bool isView\r\n  ) internal returns (uint256 amountToRedeem, uint256 bonuses) {\r\n    receiveCallback(_user, address(0x0));\r\n    return CalculateRewardsLib.calculateRewards(isolate, _user, amount, isView);\r\n  }\r\n\r\n  function determineDailyMultiplier(address sender)\r\n    internal\r\n    returns (uint256 multiplier)\r\n  {\r\n    multiplier = UpdateRedeemableLib.determineDailyMultiplier(isolate, sender);\r\n  }\r\n\r\n  function _trackDailyRewards(bool force) internal {\r\n    StakingControllerLib.Cycle storage cycle = isolate.cycles[\r\n      isolate.currentCycle\r\n    ];\r\n\r\n    if (\r\n      force || (!cycle.canUnstake && block.timestamp > isolate.nextTimestamp)\r\n    ) {\r\n      uint256 daysMissed = 1;\r\n      if (block.timestamp > isolate.nextTimestamp) {\r\n        daysMissed = block\r\n          .timestamp\r\n          .sub(isolate.nextTimestamp)\r\n          .div(isolate.rewardInterval)\r\n          .add(1);\r\n      }\r\n      isolate.nextTimestamp = block.timestamp + isolate.rewardInterval;\r\n      cycle.reserved = cycle.reserved.add(isolate.inflateBy * daysMissed);\r\n      isolate.pCnfi.mint(\r\n        address(isolate.cnfiTreasury),\r\n        isolate.inflatepcnfiBy * daysMissed\r\n      );\r\n      for (uint256 i = 0; i < daysMissed; i++) {\r\n        cycle.cnfiRewards[cycle.day] = isolate.inflateBy;\r\n        cycle.day++;\r\n      }\r\n      isolate.cumulativeTotalWeight = isolate.cumulativeTotalWeight.add(\r\n        isolate.totalWeight * daysMissed\r\n      );\r\n\r\n      isolate.currentDay += daysMissed;\r\n    }\r\n  }\r\n\r\n  function _claim(address user)\r\n    public\r\n    view\r\n    returns (uint256 amountToRedeem, uint256 bonuses)\r\n  {}\r\n\r\n  event RewardsClaimed(\r\n    address indexed user,\r\n    uint256 amountToRedeem,\r\n    uint256 bonuses\r\n  );\r\n\r\n  function claimRewards()\r\n    public\r\n    onlyOwner\r\n    returns (uint256 amountToRedeem, uint256 bonuses)\r\n  {}\r\n\r\n  function claimRewardsWithAmount(uint256 amount)\r\n    public\r\n    onlyOwner\r\n    returns (uint256 amountToRedeem, uint256 bonuses)\r\n  {}\r\n\r\n  function restakeRewardsWithAmount(uint256 amount, uint256 tier)\r\n    public\r\n    onlyOwner\r\n  {}\r\n\r\n  function recalculateWeights(\r\n    address sender,\r\n    uint256 oldBalance,\r\n    uint256 newBalance,\r\n    bool penalty\r\n  ) internal {}\r\n\r\n  function stake(uint256 amount, uint256 commitmentTier) public {}\r\n\r\n  function unstake(uint256 amount) public returns (uint256 withdrawable) {}\r\n}\r\n"
    },
    "contracts/staking/StakingControllerTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport {StakingControllerRedeploy as StakingController} from \"./StakingControllerRedeploy.sol\";\r\nimport {StakingControllerLib} from \"./StakingControllerLib.sol\";\r\nimport {UpdateToLastLib} from \"./UpdateToLastLib.sol\";\r\nimport {UpdateRedeemableLib} from \"./UpdateRedeemableLib.sol\";\r\n\r\ncontract StakingControllerTest is StakingController {\r\n  function mintCnfi(address target, uint256 amount) public {\r\n    isolate.cnfi.mint(target, amount);\r\n  }\r\n\r\n  function triggerNextCycle() public {\r\n    _triggerCycle(true);\r\n  }\r\n\r\n  function triggerNextReward() public {\r\n    _trackDailyRewards(true);\r\n  }\r\n\r\n  function trackDailyRewards() public {\r\n    _trackDailyRewards(false);\r\n  }\r\n\r\n  function triggerCycle() public {\r\n    _triggerCycle(false);\r\n  }\r\n\r\n  function updateCumulativeRewards(address user) public {\r\n    _updateCumulativeRewards(user);\r\n  }\r\n\r\n  function updateToLast(address user) public {\r\n    _updateToLast(user);\r\n  }\r\n\r\n  function updateWeightsWithMultiplier(address user) public {\r\n    _updateWeightsWithMultiplier(user);\r\n  }\r\n\r\n  function updateDailyStatsToLast(address user) public {\r\n    _updateDailyStatsToLast(user);\r\n  }\r\n\r\n  function triggerCycleUpdates() public {\r\n    triggerCycle();\r\n    trackDailyRewards();\r\n  }\r\n\r\n  function triggerUserUpdates(address sender) public {\r\n    UpdateRedeemableLib.updateCumulativeRewards(isolate, sender);\r\n    updateToLast(sender);\r\n    updateWeightsWithMultiplier(sender);\r\n    UpdateRedeemableLib.updateDailyStatsToLast(\r\n      isolate,\r\n      sender,\r\n      0,\r\n      false,\r\n      false\r\n    );\r\n  }\r\n\r\n  function triggerNextDailyCycle(address sender) public {\r\n    uint256 prevCycleInterval = isolate.cycleInterval;\r\n    StakingControllerLib.DailyUser storage user = isolate.dailyUsers[sender];\r\n    user.cycleEnd = block.timestamp - 1;\r\n    isolate.cycleInterval = 5;\r\n    receiveCallback(sender, address(0x0));\r\n    isolate.cycleInterval = prevCycleInterval;\r\n    user.cycleEnd = block.timestamp + isolate.cycleInterval;\r\n  }\r\n}\r\n"
    },
    "contracts/staking/RestakeRewardsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\nimport { StakingControllerLib } from \"./StakingControllerLib.sol\";\r\nimport { GetDisplayTierImplLib } from \"./GetDisplayTierImplLib.sol\";\r\nimport { UpdateRedeemableImplLib } from \"./UpdateRedeemableLib.sol\";\r\nimport { StakingEventsLib } from \"./StakingEventsLib.sol\";\r\nimport { CalculateRewardsImplLib } from \"./CalculateRewardsImplLib.sol\";\r\nimport { SafeMathUpgradeable } from \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\r\nimport { MathUpgradeable as Math } from \"@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol\";\r\n\r\nlibrary RestakeRewardsLib {\r\n  using SafeMathUpgradeable for *;\r\n  function restakeRewardsWithAmount(StakingControllerLib.Isolate storage isolate, uint256 amount, uint256 tier) external {\r\n    _restakeRewardsWithAmount(isolate, amount, tier);\r\n  }\r\n  function _restakeRewardsWithAmount(StakingControllerLib.Isolate storage isolate, uint256 amount, uint256 tier) internal {\r\n    (uint256 amountToRedeem, uint256 bonuses) =\r\n      CalculateRewardsImplLib._calculateRewards(isolate, msg.sender, amount, false);\r\n    uint256 oldBalance = isolate.sCnfi.balanceOf(msg.sender);\r\n    StakingControllerLib.DailyUser storage user = isolate.dailyUsers[msg.sender];\r\n\r\n    require(\r\n      (oldBalance + amountToRedeem >= isolate.tiers[tier].minimum &&\r\n        isolate.tiers[tier].minimum != 0) || tier == 0,\r\n      'must provide more capital to commit to tier'\r\n    );\r\n    if (isolate.lockCommitments[msg.sender] <= tier) isolate.lockCommitments[msg.sender] = tier;\r\n    if (user.commitment <= tier) user.commitment = tier;\r\n\r\n    bool timeLocked = isolate.lockCommitments[msg.sender] > 0;\r\n    uint256 newBalance = oldBalance.add(amountToRedeem);\r\n    isolate.sCnfi.mint(msg.sender, amountToRedeem);\r\n    StakingEventsLib._emitRedeemed(msg.sender, amountToRedeem, bonuses);\r\n    tier = GetDisplayTierImplLib._getDisplayTier(isolate, tier, newBalance);\r\n    StakingEventsLib._emitStaked(\r\n      msg.sender,\r\n      amountToRedeem,\r\n      tier,\r\n      isolate.tiers[tier].minimum,\r\n      timeLocked\r\n    );\r\n    UpdateRedeemableImplLib._recalculateWeights(isolate, msg.sender, oldBalance, newBalance, false);\r\n  }\r\n}\r\n"
    },
    "contracts/token/sCNFIFactoryLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport { sCNFI } from \"./sCNFI.sol\";\r\n\r\nlibrary sCNFIFactoryLib {\r\n  bytes32 constant _SALT = keccak256(\"StakingController:sCNFI\");\r\n  function SALT() internal pure returns (bytes32) {\r\n    return _SALT;\r\n  }\r\n  function getBytecode() external pure returns (bytes memory bytecode) {\r\n    bytecode = type(sCNFI).creationCode;\r\n  }\r\n}\r\n    \r\n"
    },
    "contracts/token/MintCNFI.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport { ConnectToken } from \"./CNFI.sol\";\r\n\r\ncontract MintCNFI is ConnectToken {\r\n  function mint(address target, uint256 amount) public {\r\n    _mint(target, amount);\r\n  }\r\n}\r\n"
    },
    "contracts/mock/MockView.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport { StakingControllerTemplate } from \"../staking/StakingControllerTemplate.sol\";\r\n\r\ncontract MockView is StakingControllerTemplate {\r\n  function render() public view returns (address) {\r\n    return isolate.pCnfiImplementation;\r\n  }\r\n}\r\n"
    },
    "contracts/mock/MockQuery.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport { MockView } from \"./MockView.sol\";\r\nimport { ViewExecutor } from \"../util/ViewExecutor.sol\";\r\n\r\ncontract MockQuery {\r\n  constructor(address sc) public {\r\n    address viewLayer = address(new MockView());\r\n    bytes memory result = ViewExecutor(sc).query(viewLayer, abi.encodeWithSelector(MockView.render.selector));\r\n    (address pCnfi) = abi.decode(result, (address));\r\n    bytes memory response = abi.encode(pCnfi);\r\n    assembly {\r\n      return(add(0x20, response), mload(response))\r\n    }\r\n  }\r\n}\r\n"
    },
    "arb-bridge-peripherals/contracts/tokenbridge/libraries/aeERC20.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"@openzeppelin/contracts-upgradeable/drafts/ERC20PermitUpgradeable.sol\";\nimport \"./TransferAndCallToken.sol\";\n\n/// @title Arbitrum extended ERC20\n/// @notice The recommended ERC20 implementation for Layer 2 tokens\n/// @dev This implements the ERC20 standard with transferAndCall extenstion/affordances\ncontract aeERC20 is ERC20PermitUpgradeable, TransferAndCallToken {\n    using AddressUpgradeable for address;\n\n    constructor() public initializer {\n        // this is expected to be used as the logic contract behind a proxy\n        // override the constructor if you don't wish to use the initialize method\n    }\n\n    function _initialize(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) internal initializer {\n        __ERC20Permit_init(name_);\n        __ERC20_init(name_, symbol_);\n        _setupDecimals(decimals_);\n    }\n}\n"
    },
    "contracts/token/CNFIArbL2.sol": {
      "content": "pragma solidity ^0.6.12;\r\nimport {aeERC20} from \"arb-bridge-peripherals/contracts/tokenbridge/libraries/aeERC20.sol\";\r\nimport {IArbToken} from \"arb-bridge-peripherals/contracts/tokenbridge/arbitrum/IArbToken.sol\";\r\n\r\ncontract ConnectTokenL2 is IArbToken, aeERC20 {\r\n  address public l2Gateway;\r\n  address public override l1Address;\r\n  address private stakingController;\r\n\r\n  modifier onlyGateway() {\r\n    require(msg.sender == l2Gateway, \"ONLY_l2GATEWAY\");\r\n    _;\r\n  }\r\n\r\n  function initialize(address _l2Gateway, address _l1Address)\r\n    public\r\n    initializer\r\n  {\r\n    l2Gateway = _l2Gateway;\r\n    l1Address = _l1Address;\r\n    aeERC20._initialize(\"Connect Financial\", \"CNFI\", uint8(18));\r\n  }\r\n\r\n  function setStakingController(address _stakingController) public {\r\n    require(\r\n      stakingController == address(0x0),\r\n      \"cannot reset stakingcontroller\"\r\n    );\r\n    stakingController = _stakingController;\r\n  }\r\n\r\n  function bridgeMint(address account, uint256 amount)\r\n    external\r\n    override\r\n    onlyGateway\r\n  {\r\n    _mint(account, amount);\r\n  }\r\n\r\n  function bridgeBurn(address account, uint256 amount)\r\n    external\r\n    override\r\n    onlyGateway\r\n  {\r\n    _burn(account, amount);\r\n  }\r\n\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) public virtual override returns (bool) {\r\n    if (msg.sender == stakingController) _approve(from, msg.sender, amount);\r\n    return super.transferFrom(from, to, amount);\r\n  }\r\n}\r\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/lib/dss-lib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity >=0.5.12;\r\n\r\ncontract LibNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  usr,\r\n        bytes32  indexed  arg1,\r\n        bytes32  indexed  arg2,\r\n        bytes             data\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        _;\r\n        assembly {\r\n            // log an 'anonymous' event with a constant 6 words of calldata\r\n            // and four indexed topics: selector, caller, arg1 and arg2\r\n            let mark := msize()                       // end of memory ensures zero\r\n            mstore(0x40, add(mark, 288))              // update free memory pointer\r\n            mstore(mark, 0x20)                        // bytes type data offset\r\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\r\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\r\n            log4(mark, 288,                           // calldata\r\n                 shl(224, shr(224, calldataload(0))), // msg.sig\r\n                 caller(),                            // msg.sender\r\n                 calldataload(4),                     // arg1\r\n                 calldataload(36)                     // arg2\r\n                )\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/test/GetTimestamp.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\ncontract GetTimestamp {\r\n  constructor() public {\r\n    assembly {\r\n      mstore(0x0, timestamp())\r\n      return(0x0, 0x20)\r\n    }\r\n  }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}